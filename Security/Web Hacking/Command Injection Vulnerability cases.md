# Command Injection Vulnerability cases
* 모든 시스템 명령어가 Command Injection에 취약한 것은 아님 → 각 함수의 특징을 정확히 이해하고 있어야 함
* 패치가 적용되었을 경우 이를 우회할 수 있는 방법을 모색하는 것이 중요함

<br/>

## ruby & perl
* ```open``` 함수: 루비(Ruby)와 펄(Perl)에서 파일 또는 하위 프로세스의 I/O를 제공하는 함수
    - ```open``` 함수의 인자
        + 해당 함수의 인자로 파일명이 전달되면 파일을 읽거나 쓸 수 있음
        + 인자의 첫 번째 문자가 ```|```(pipe, vertical bar)d이면 ```pipe_open``` 함수에서 처리함
    - C 언어의 ```system``` 함수와 같이 새로운 프로세스를 생성함 → **임의 명령어를 실행할 수 있음**
    - ```open``` 함수가 호출되는 과정은 ```pipe_open_s``` 실행 과정을 통해 확인할 수 있음

<br/>

### pipe_open_s 실행 과정
1. ```open``` 함수를 호출하면 아래의 코드를 실행함
    ```ruby
    rb_define_global_function("open", rb_f_open, -1);

    static VALUE rb_f_open(int argc, VALUE *argv, VALUE _) {
        ID to_open = 0;
        int redirect = FALSE;

        if (argc >= 1) {
            CONST_ID(to_open, "to_open");
            if (rb_respond_to(argv[0], to_open)) {
                redirect = TRUE;
            } else {
                VALUE tmp = argv[0];
                FilePathValue(tmp);
                if (NIL_P(tmp)) {
                    redirect = TRUE;
                } else { # 전달된 인자가 존재하는 경우
                    VALUE cmd = check_pipe_command(tmp); # check_pipe_command 함수를 호출 (|가 존재하는지 검사)
                    if (!NIL_P(cmd)) { # | 문자가 포함되어 있는 경우
                        argv[0] = cmd; # 인자를 반환함
                        return rb_io_s_popen(argc, argv, rb_cIO); # rb_io_s_open 함수를 호출
                    }
                }
            }
        }
        ...
    }

    static VALUE check_pipe_command(VALUE filename_or_command) {
        char *s = RSTRING_PTR(filename_or_command);
        long l = RSTRING_LEN(filename_or_command);
        char *e = s + l;
        int chlen;
        if (rb_enc_ascget(s, e, &chlen, rb_enc_get(filename_or_command)) == '|') { # filename_or_command 인자값에 '|' 문자가 포함되는지 확인
            VALUE cmd = rb_str_new(s + chlen, l - chlen);
            return cmd;
        }
        return Qnil;
    }
    ```
    - ```check_pipe_open``` 함수로 인자에 ```|``` 문자가 포함되어 있는지 확인하여 포함되어 있을 경우 ```rb_io_s_open``` 함수를 호출함
2. ```rb_io_s_open``` 함수는 내부애서 ```rb_io_popen``` 함수를 호출함
    ```ruby
    VALUE
    rb_io_popen(VALUE pname, VALUE pmode, VALUE env, VALUE opt){
        const char *modestr;
        VALUE tmp, execarg_obj = Qnil;
        int oflags, fmode;
        convconfig_t convconfig;

        tmp = rb_check_array_type(pname);
        if (!NIL_P(tmp)) {
        long len = RARRAY_LEN(tmp);
    #if SIZEOF_LONG > SIZEOF_INT
        if (len > INT_MAX) {
            rb_raise(rb_eArgError, "too many arguments");
        }
    #endif
            execarg_obj = rb_execarg_new((int)len, RARRAY_CONST_PTR(tmp), FALSE, FALSE);
        RB_GC_GUARD(tmp);
        }
        else {
        SafeStringValue(pname);
        execarg_obj = Qnil;
        if (!is_popen_fork(pname))
                execarg_obj = rb_execarg_new(1, &pname, TRUE, FALSE);
        }
        if (!NIL_P(execarg_obj)) {
        if (!NIL_P(opt))
            opt = rb_execarg_extract_options(execarg_obj, opt);
        if (!NIL_P(env))
            rb_execarg_setenv(execarg_obj, env);
        }
        rb_io_extract_modeenc(&pmode, 0, opt, &oflags, &fmode, &convconfig);
        modestr = rb_io_oflags_modestr(oflags);
        return pipe_open(execarg_obj, modestr, fmode, &convconfig); # pipe_open 함수를 호출하여 프로세스를 생성함
    }
    ```
    - ```ro_io_popen``` 함수를 호출하면 ```pipe_open``` 함수를 호출해 프로세스를 생성함 → **```open``` 함수의 인자를 조작할 수 있다면 임의 명령어를 실행할 수 있음**

<br/>

### Command Injection 취약점이 발생할 수 있는 다른 I/O 함수
* ```rb_io_open_generic``` 함수
    ```ruby
    static VALUE rb_io_open_generic(VALUE klass, VALUE filename, int oflags,
                                    int fmode, const convconfig_t *convconfig,
                                    mode_t perm) {
    VALUE cmd;
    if (klass == rb_cIO && !NIL_P(cmd = check_pipe_command(filename))) {
        return pipe_open_s(cmd, rb_io_oflags_modestr(oflags), fmode, convconfig);
    } else {
        return rb_file_open_generic(io_alloc(klass), filename, oflags, fmode,
                                    convconfig, perm);
    }
    }
    ```
    - ```open``` 함수처럼 ```rb_define_global_function```으로 등록된 함수는 아님
    - 전달된 인자의 첫 문자가 ```|```인지 확인하고 프로세스의 생성 여부를 결정함
        - ```check_pipe_command``` 함수를 이용해 filename에 ```|``` 문자가 포함되어 있는지 확인함
            + 포함되어 있으면 ```pipe_open_s``` 함수를 호출함
            + 포함되어 있지 않으면 ```rb_file_open_generic``` 함수를 호출함

<br/>

### 공격 예시
* ruby의 Command Injection 예시
    ```ruby
    # irb(main):... > 다음에 입력
    open("|rd > /tmp/1")
    IO.read("/tmp/1")
    # 결과: "uid=1000(...) gid=1000(...) groups=1000(...)\n"

    IO.read("|id")
    # 결과: "uid=1000(...) gid=1000(...) groups=1000(...)\n"

    IO.binread("|id");
    # 결과: "uid=1000(...) gid=1000(...) groups=1000(...)\n"
    ```
    - ```rb_io_s_binread```, ```rb_io_open```, ```rb_io_s_read```를 사용한 ```IO.read```, ```IO.binread``` 등이 전달된 인자에 따라 프로세스를 실행함
    - 각 함수의 인자로 ```|``` 문자와 함께 명령어를 실행함
* perl의 Command Injection 예시
    ```
    # 터미널에서 입력
    perl -e 'open A, "|id"'
    # 결과: uid=1000(...) gid=1000(...) groups=1000(...)
    ```

<br/><br/>

## PHP
* ```system``` 함수: PHP에서 시스템 명령어를 실행하기 위헤 제공하는 함수
    - 📚 [PHP system documentation](https://www.php.net/manual/en/function.system.php)
        ```php
        system(string $command, int &$result_code = null): string|false
        ```
        + 실행할 명령($command)와 결과 코드($result_code)를 매개변수의 값으로 받아, 성공 시 명령의 마지막 줄을 반환하고 실패 시 false를 반환함
            - ```$result_code```는 선택 사항으로 있다면 실행한 명령의 반환 상태가 여기에 기록됨

<br/>

### escapeshellcmd 함수
* PHP에서 메타 문자를 통한 Command Injection을 방지하고 위해 사용하는 함수
    - 메타 문자가 입력되었을 때 해당 문자 앞에 ```\```을 삽입해 타 명령어를 실행할 수 없도록 함
    - 📚 [PHP escapeshellcmd documentation](https://www.php.net/manual/en/function.escapeshellcmd.php)
        ```php
        escapeshellcmd(string $command): string
        ```
        + 임의의 명령을 실행하도록 셸 명령을 속이는 데 사용할 수 있는 모든 문자열을 이스케이프함
        + 데이터가 ```exec()``` 또는 ```system()``` 함수 또는 백틱(backtick) 연산자로 전달되기 전에 사용자 입력에서 오는 모든 문자가 이스케이프되도록 하는 데 사용해야 함
        + 이스케이프될 명령(command)를 매개변수로 받아 이스케이프된 문자열을 반환함
* escapeshellcmd 함수를 이용한 PHP Command Injection 패치 예시
    - PHP Command Injection이 발생하는 예시
        ```php
        <?php
            $cmd = "ls ".$_GET['filename']." 2>&1";
            system($cmd);
        ?>
        ```
    - escapeshellcmd 함수를 이용해 PHP Command Injection 패치 예시
        ```php
        <?php
            $cmd = "ls ".escapeshellcmd($_GET['filename'])." 2> &1";
            system($cmd);
        ?>
        ```
* ```escapeshellcmd``` 함수로 입력값에 포함된 메타 문자를 이스케이프하는 경우 **메타 문자를 사용한 Command Injection**은 불가능함
    - 특정 명령어의 인자로 입력값이 전달되는 경우 공격자는 실행하려는 명령어의 옵션 또는 인자를 조작할 수 있음
        + escapeshellcmd 함수를 사용할 때 명령어의 옵션/인자를 조작하는 예시
            - ```curl 'http://sample.com/cmdInjection.php?filename=-al%20/etc/passwd;%20id'```
                + filename의 값인 ```-al%20/etc/passwd;%20id```의 메타 문자가 이스케이프 처리되어 '/etc/passwd;'와 'id' 문자열을 이름으로 가지는 파일 또는 디렉터리를 찾을 수 없다는 결과를 반환함 <br/> &nbsp;&nbsp; ⇒ ```id``` 명령어를 실행할 수 없게 막음 (Command Injection 방지)
            - ```curl 'http://sample.com/cmdInjection.php?filename=-al%20/etc/passwd'```'
                + filename의 값인 ```-al%20/etc/passwd```를 escapeshellcmd 함수로 처리한 결과 '-al /etc/passwd` 문자열이 반환되어 system 함수에 의해 ```ls -al /etc/passwd 2>&1```가 실행되어 결과를 출력함 <br/> &nbsp;&nbsp; ⇒ 인자와 옵션에 대해서는 이스케이프 처리할 수 없기 때문에 Command Injection을 이용해 정보 획득 가능

<br/>

### escapeshellarg 함수
* PHP에서 명령어의 인자를 조작할 수 없도록 하기 위해 사용하는 함수
    - 셸 인수로 사용할 문자열을 이스케이프 처리함
    - 📚 [PHP escapeshellarg documentation](https://www.php.net/manual/en/function.escapeshellarg.php)
        ```php
        escapeshellarg(string $arg): string
        ```
        + 문자열 주위에 작은 따옴표를 추가하고 기존의 작은 따옴표를 따옴표/이스케이프 처리하여 문자열을 셸 함수에 직접 전달하고 하나의 안전한 인수로 처리하도록 함
        + 사용자 입력에서 오는 셸 함수(```exec()``` 함수, ```system()``` 함수, 백틱 연산자)에 대한 개별 인수를 이스케이프하는 데 사용해야 함
        + 이스케이프될 인수(arg)를 매개변수로 받아 이스케이프된 문자열을 반환함
* escapeshellcmd 함수와 escapeshellarg 함수의 비교
    | 함수 | 예시 | 결과 |
    |---|----|----|
    | escapeshellcmd | ```var_dump(escapeshellcmd("a -h -d -e"));``` | ```string(10) "a -h -d -e"``` <br/>(전달한 입력값이 그대로 반환됨) |
    | escapeshellarg | ```var_dump(escapeshellarg("a -h -d -e"));``` | ```string(12) "'a -h -d - e'"``` <br/>(하나의 문자열(```'a -h -d -e'```)로 반환됨) |

<br/>

## PHP 공격 예시
* 모든 명령어가 인자를 조작한다고 해서 서버에 악영향을 끼치는 것은 아님
* 옵션으로 임의의 명령어를 실행할 수 있는 기능을 제공하는 프로그램의 경우 해당 프로그램의 인자를 조작할 수 있는 상황이라면 커맨드 인젝션 공격이 가능함

### zip
* 압축 파일을 생성하거나 해제하는 명령어
    - 터미널에 ```sudo apt install zip```을 통해 설치할 수 있음
    - ```zip --help```와 ```zip -h2```를 입력하여 zip 명령어에 대한 설명을 볼 수 있음
        <img width="726" alt="zip명령어" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/ef6aa67b-62a6-478f-bf7d-aa2504533abe">
* ```--unzip-command``` 옵션
    - 압축 파일을 테스트할 때 사용하는 옵션 → **인자로 전달된 명령어를 실행함**
    - EX: "sh -c id"를 인자로 전달하여 id 명령어를 실행하는 예시
        ```linux
        zip /tmp/test/zip ./practice -T --unzip-command="sh -c id"
        ```
        <img width="727" alt="zip_commandInjection" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/13e1f754-3c65-48c2-848a-bd3ff91352b0">

<br/>

### python
* 파이썬 코드를 실행시키는 명령어
    - 터미널에 ```sudo apt install python```(python3 설치 시에는 ```sudo apt install python3```)를 통해 설치할 수 있음
    - ```python --help``` 또는 ```python3 --help```를 터미널에 입력하여 python 명령어에 대한 설명을 볼 수 있음
        <img width="731" alt="python3_help" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/c5c3a5d3-e5ff-48d3-932e-a48816afa6ab">
* ```-c``` 옵션
    - 명령줄로 코드를 실행시킬 수 있는 옵션
    - EX: python 명령어의 ```-c``` 옵션을 이용한 시스템 명령어의 실행
        ```linux
        python -c '__import__("os").system("id")' input.py
        ```
        <img width="729" alt="python-c" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/ddba86da-c7a5-4672-9bab-f67d29054546">

<br/>

### curl
* 프로토콜들을 이용해 URL로 데이터를 전송하여 서버에 데이터를 보내거나 가져올 때 사용하는 명령줄 도구 및 라이브러리 (인자로 전달된 URL에 접속하는 CLI 프로그램)
    - 특정 서버에서 방화벽 예외 상태를 테스트하거나 REST 서비스 테스트를 위해 사용됨
    - Linux, MacOS에 기본 탑재되어 있음 (Windows에서는 다른 편리한 프로그램이 많기 때문에 잘 사용되지 않음)
    - (우분투 리눅스) 터미널에 ```sudo apt install curl```을 입력해 설치할 수 있음
    - 자세한 설명은 [리눅스 curl](https://github.com/augustf86/Today_I_Learn/blob/main/Security/Supplement/Linux_curl.md) 추가자료를 참고
* ```-o``` 옵션
    - curl 명령어의 결과를 임의 경로에 파일로 저장할 수 있게 하는 옵션
    - 예시: ```http://sample.com```에서 반환하는 데이터를 "hello.txt" 파일로 저장하는 예시
        ```linux
        curl http://sample.com -o /tmp/hello.txt
        ```
        + ```cat /tmp/hello.txt```로 데이터를 확인할 수 있음

<br/>

### wget
* HTTP, HTTPS 및 FTP 프로토콜을 사용하여 웹 서버에서 파일을 다운로드하는 데 도움을 주는 리눅스 커맨드라인 유틸리티 (전달된 URL에 접속해 파일을 다운로드하는 프로그램)
    - 다양한 옵션을 사용해 다운로드 상황을 제어함
    - (우분투 리눅스) 터미널에 ```sudo apt install wget```을 입력해 설치할 수 있음
* ```-O``` 옵션
    - wget 명령어의 실행 결과로 다운로드한 파일을 임의 경로에 저장할 수 있게 하는 옵션
    - 예시: ```http://sample.com```에서 반환하는 데이터를 "hello.txt" 파일로 저장하는 예시
        ```linux
        curl http://sample.com -O hello.txt
        ```
        + ```cat /tmp/hello.txt```로 데이터를 확인할 수 있음



<br/><br/><br/><br/>
### 🔖 출처
* [드림핵 Web Hacking Advanced - Server Side] 📌 [ExploitTech: Command Injection Vulnerability cases](https://dreamhack.io/lecture/courses/296)
