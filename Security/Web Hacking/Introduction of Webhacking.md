# Introduction of Webhacking
🔖 출처: [Dreamhack Lecture] Introduction of Webhacking [🔗](https://dreamhack.io/lecture/courses/6)

<br/><br/>

## Web
* Web의 정의
    | | 설명 |
    |:---:|------|
    | 사전적 정의 | 인터넷에 연결된 컴퓨터들이 하이퍼텍스트 형식으로 표현된 다양한 정보를 효과적으로 이용할 수 있도록 구현된 전세계적인 시스템 <br/> &nbsp;&nbsp; - 시간과 장소에 구애받지 않고 인터넷에 접속할 수만 있다면 누구나 웹에서 정보를 구하거나 공유할 수 있음 <br/> &nbsp;&nbsp; - 인터넷 상에서 각각의 사용자(컴퓨터)가 거미줄처럼 연결되어 서로 정보를 공유한다는 의미에서 웹이 유래함|
    | 기술적 정의 | 인터넷을 기반으로 구현된 서비스 중 **HTTP를 이용하여 정보를 공유**하는 서비스 <br/> &nbsp;&nbsp; - 웹을 이용하는 컴퓨터들은 웹 서버(Web Server)와 웹 클라이언트(Web Client)로 구분할 수 있음 <br/> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - **웹 서버**(Web Server): 웹 서비스를 제공하는 주체 <br/> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - **웹 클라이언트**(Web Client): 웹 서비스를 제공받는 이용자 |
    - Web의 정확한 어원은 ***월드 와이드 웹***(World Wide Web, WWW, W3)이지만 간단히 웹(Web)이라고 부르는 경우가 더 많음

<br/>

* Web의 특징
    - 전세계적으로 가장 많이 사용되는 인터넷 서비스임
        + 이유
            | | 이유 |
            |:--:|------|
            | 1 | 웹 브라우저의 등장과 발전으로 대중적인 접근성이 높아짐 |
            | 2 | 다양항 형태의 서비스가 가능함 |
    - 인터넷 서비스 중 손쉽게 접근 가능함
        + 단순히 웹 사이트에 접속하는 형태 외에도 모바일 서비스, IoT 장비의 관리 페이지 등 다양한 형태로 일상생활 전반에 사용되고 있음

<br/>

* 💡 [Additional] 웹 서비스의 종류
    | | 설명 |
    |:---:|------|
    | **프론트엔드** <br/> (Front-end) | ***이용자의 요청을 받는 부분*** (= 이용자에게 보여지는 부분) <br/> &nbsp;&nbsp; - 웹 리소스(Web Resource)로 구성됨 *→ 페이지가 보여지고 있는 정보들은 모두 웹 리소스에 명시되어 있다는 것을 의미함* <br/> &nbsp;&nbsp; - ⚠️ 공격자가 쉽게 변조할 수 있는 대상이므로 좀 더 주의깊게 살펴봐야 함 |
    | **백엔드** <br/> (Back-end) | ***이용자의 요청을 처리하는 부분*** (= 이용자에게 보여지지 않는 부분) <br/> &nbsp;&nbsp; - 백엔드(서버)에서 제공하는 기능: 서버 측 스크립트 언어, 웹 서버, 데이터베이스 <br/> &nbsp;&nbsp; - 현재는 사용자가 입력한 값에 따라 다양한 결과를 화면에 보여주는 동적 기능도 제공하고 있음 |

<br/><br/>

### 웹의 역사
| | 설명 |
|:---:|------|
| 과거 | 초기 웹은 **지정된 문서의 내용을 출력해 사용자에게 제공하는 간단한 서비스**였음 <br/> &nbsp;&nbsp; - 이용자가 요청하는 정보를 제공하기만 하는 수동적인 형태의 서비스 → 별다른 로직 없이 **정적 페이지를 보여주는 기능**만 제공함 <br/> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ↳ 단순히 텍스트와 링크 위주로 이루어진, 하이퍼링크(Hyperlink)로 여러 페이지를 묶어넣은 정도|
| 현재 | 업무, 금융, 쇼핑 등 **다양한 분야에서 이용자에게 편의를 주는 복잡한 서비스**로 발전함 <br/> &nbsp;&nbsp; - 이용자의 요청을 해석하고 가공하여 필요한 정보를 제공하는 능동적인 형태의 서비스 <br/> &nbsp;&nbsp;&nbsp;&nbsp; → 사용자의 입력과 입력에 따른 기능 수행이 추가되어 사용자와 많은 부분을 상호작용함 | 
* 예시: Microsoft 홈페이지의 과거와 현재
    | | 설명 |
    |:---:|------|
    | 과거 | 단순히 정보를 제공하거나 마이크로소프트의 소프트웨어 중 하나인 Internet Explorer를 다운로드할 수 있도록 제공하는 기능 <br/>외에는 특별한 로직을 확인할 수 없음
    | 최근 | 사용자가 회원가입/로그인, 마이크로소프트 서비스 내에서 원하는 정보를 검색하거나 마이크로소프트의 제품을 웹을 통해 구매 가능해짐 |
    - 📌 **인터넷 아카이브**(https://archieve.org)를 이용하여  초창기의 웹 사이트를 살펴보는 방법
        | 순서 | 설명 |
        |:---:|------|
        | 01 | 인터넷 아카이브에 접속한 후 상단의 검색 창에 원하는 사이트의 주소를 입력한 후 [Enter] 버튼을 누름 |
        | 02 | 화면 상단의 그래프에서 연도를 선택한 다음 달력에 표시된 부분을 클릭하면 해당 시점의 웹 사이트를 살펴볼 수 있음 |

<br/>

* 웹 보안의 중요성이 대두된 배경
    - 과거에는 오프라인에서 진행되거나 물리적으로 저장되었던 정보들이 웹에서 접근 가능한 디지털 정보로 바뀌면서 **웹에서 처리하는 정보 자산들이 많아짐** <br/> &nbsp;&nbsp; → 이러한 **정보 자산에 웹을 통해 접근 가능해짐**에 따라 이를 안전하게 보관하고 처리해야 할 필요성도 함께 증가함
        | 웹에서 처리하는 정보 자산의 예시 |
        |---|
        | 이름, 전화번호, 주소, 카드 번호 등의 개인 정보 |
        | 기업 내부 자료, 임직원 정보 등 기업의 자산 |
    - **웹을 통한 정보 교환 과정에서 민감한 정보들이 유출되거나 악용되지 않도록 보호**하는 웹 보안의 중요성이 대두되고 있음

<br/><br/>

> ### ❓ 웹 해킹을 학습하기 전에 <U>웹에 대해 알아야 하는 이유</U>
> * 해킹(Hacking): 본래의 설계자나 관리자, 운영자가 의도하지 않은 동작을 일으키도록 하거나 체계 내에서 주어진 권한 이상으로 정보를 열람﹒복제﹒변경 가능하게 하는 행위
>   - 의도치 않은 행위를 발생시키기 위해서는 설계 또는 운영의 약점을 찾을 수 있어야 함 → ***공격을 위해선 해당 시스템에 대한 더 높은 이해도가 요구됨***

<br/><br/><br/>

## Web 기초 지식

### Web Browswer (웹 브라우저)
HTTP를 통해 인터넷 상에서 서버와 통신을 하며 서버로부터 전달받은 다양한 웹 리소스들을 가공해 **사용자가 웹과 HTTP의 동작 원리를 알지 못해도** 웹을 사용할 수 있도록 도와주는 소프트웨어
* 취약점이 발생하는 사용자의 입력값은 브라우저를 통해 전송됨 → 📌 <U>웹 해킹을 공부하기 위해서는 브라우저가 하는 행위를 필수적으로 이해하고 있어야 함</U>

<br/>

* 대중적으로 많이 쓰이는 웹 브라우저와 각 특징
    | | Chrome | Edge | Safari | Firefox |
    |---|----|----|----|----|
    | 제조사 | 구글 | 마이크로소프트 | 애플 | 모질라(Mozilla) 재단 |
    | Javascript 엔진 | V8 | ChakraCore | Javascript Core | Spider Monkey |
    | HTML/CSS 엔진 | Blink | EdgeHTML | Webkit | Gecko |
    | 사생활 보호/보장 (EDNS) | X | X | X | O |
    | 패스워드 동기화 | O | O | O | O |
    - 각 브라우저들이 수행하는 기본적인 기능은 동일함
    - HTML/CSS/JS의 해석 및 실행 속도나 내장 로그인을 통한 모든 디바이스 동기화 기능 등에 차별화를 두고 있음

<br/>

* 웹 브라우저를 통해 ```http://example.com/index.html```에 접속할 때 이뤄지는 통신
  <br/><br/>
  <img width="2560" alt="웹 브라우저의 통신 과정" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/a742d269-85c3-4f12-80a8-1b791dc3dcef"><br/>

<br/>

* 💡 [Additional] 웹을 사용하기 위한 다양한 방법들 비교
    | 방법 | 설명 |
    |:---:|------|
    | 네트워크 프로그램 사용 | 웹 서버가 이해하고 해석할 수 있는 형태(HTTP)의 데이터를 직접 작성하여 전송하여야 함 <br/> &nbsp;&nbsp; - nc, telnet과 같은 프로그램이 대표적임 |
    | CLI 프로그램 사용 | 서버가 응답하여 주는 데이터를 단순히 출력만 하게 됨 <br/> *= html을 해석하여 화면에 출력하는 기능, css로 스타일을 입혀주는 기능, <br/> &nbsp;&nbsp; 자바스크립트를 실행하는 기능 등은 포함되어 있지 않음* <br/> &nbsp;&nbsp; - curl, wget 등이 있음 |
    | 웹 브라우저 사용 | 웹 브라우저의 주소창에 접속하고자 하는 주소를 입력하면, 웹 브라우저는 사용자가 요청한 주소를 대신 접속해 <br/>서버에서 응답한 데이터를 해석한 후 화면에 출력함 (웹 랜더링) |

<br/>

* 💡 [Additional] **Web Rendering** (웹 랜더링): 서버로부터 받은 리소스를 이용자에게 <U>시각화</U>하는 행위
    - 서버의 응답을 받은 웹 브라우저는 리소스의 타입을 확인하고, 적절한 방식으로 이용자에게 전달함
    - 웹 랜더링 엔진에 의해서 웹 랜더링 과정이 이루어지며, 브라아주별로 서로 다른 엔진을 사용함
        + 각각의 엔진에 따라 랜더링 과정과 순서, 속도의 차이는 존재함
        + ❗️ HTML을 파싱하고 시각화하여 이용자에게 보여주는 것은 동일함

<br/>

* 📌 Browser Devtools (개발자 도구)
    - 크롬, 사파리, 엣지, 파이어폭스 모두 개발자 도구를 포함하고 있으며, 각각의 인터페이스는 조금씩 다르지만 기본적인 기능은 흡사함
    - 개발자 도구의 기능
        + HTML, CSS 코드를 브라우저에서 수정하고 결과를 바로 확인할 수 있음
        + 자바스크립트 코드를 대상으로 디버거도 제공함
        + 서버와 오가는 HTTP 패킷을 상세하게 볼 수 있음 → 프로토콜 상에서 발생하는 문제도 쉽게 발견 가능
    - 🛠️ [MacOS, Chrome 브라우저] DevTools 실행 방법
        | | 방법 |
        |:---:|------|
        | 01 | 단축키 ***Option + Command + I***를 사용함 |
        | 02 | 크롬 브라우저의 메뉴에서 ***보기 - 개발자 정보 - 개발자 도구***를 클릭 |
        + 개발자 도구의 주요 탭 설명
          <br/><br/>
          <img width="2560" alt="브라우저 개발자 도구" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/e07929e0-8691-4974-82f3-d15660415773"><br/>
    - 🔗 자세한 내용은 [Tools: Browser DevTools]()을 참고


<br/><br/>

### Web Resource (웹 리소스)
웹에서 사용하는 콘텐츠
* 📌 <U>모든 웹 리소스들은 고유의 URI(Uniform Resource Indicator)를 가지고, 이를 이용하여 식별됨</U>
* 사용자의 요청이 서버로 들어오면 서버는 웹 리소스들로 응답하며, 웹 브라우저는 사용자가 볼 수 있는 형태로 가공하여 화면에 출력함

<br/>

* 웹 브라우저의 주소창에 입력한 주소 ```http://samplesite.com/index.html```의 의미 <br/> &nbsp;&nbsp; → ```samplesite.com```에 존재하는 ```/index.html``` 리소스에 대한 요청을 수행하는 것

<br/>

* 페이지를 구성하는 대표적인 웹 리소스들
    | 웹 리소스 | 설명 |
    |:---:|------|
    | HTML | **Hyper Text Markup Language**의 약자 <br/> 웹 문서의 뼈대를 구축하기 위한 마크업 언어 <br/> &nbsp;&nbsp; - 정해진 태그(```<태그명>```)과 태그 내 속성(```속성명="속성값"```)을 지정하여 문서를 구성함 <br/> &nbsp;&nbsp; - 현재는 HTML5가 표준으로 확정되었고, 지속적으로 발전하고 있음 |
    | CSS | **Cascading Style Sheets**의 약자 <br/> HTML이 표시되는 방법을 정의하는 스타일 시트 언어 <br/> &nbsp;&nbsp; - 이미지, 태그, 글자 등 다양한 웹 리소스들의 출력 시 스타일을 정함 *→ 웹 사이트의 외관, 즉 디자인을 담당함* <br/> &nbsp;&nbsp; - 웹 브라우저는 CSS를 참고하여 웹 문서를 시각화함 |
    | JS | **Javascript**의 약자 <br/> 이용자의 브라우저에서 실행되며, 페이지 내에서의 행위들을 설정할 수 있는 프로그래밍 언어 (Client-Side Script) <br/> &nbsp;&nbsp; - 성능 문제로 인해 서버 측에서 처리하지 않는 부분을 클라이언트 측에서 처리할 때 주로 사용함 |
    | Etc | 웹 페이지 내의 문서, 이미지, 동영상, 폰트 등 |

<br/><br/>

### URI / URL
* URI와 URL의 비교
    | URI | URL |
    |------|------|
    | **Uniform Resource Indicator**의 약자 <br/> 리소스를 식별하기 위한 식별자 | **Uniform Resource Locator**의 약자 <br/> 리소스의 **위치**를 식별하기 위한 <U>URI의 하위 개념</U> |
    - 📌 웹에서 접속할 때 웹 사이트의 주소(위치)를 이용해 접근하는 것은 URL이자 URI를 사용한 것 <br/> &nbsp;&nbsp; → **최근 들어서는 둘을 혼용해서 사용하는 추세임**

<br/>

* URI (Uniform Resource Indicator)
  <br/><br/>
  <img width="2560" alt="URI의 구성 요소" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/8d9db785-4175-4ab9-865b-ebbef7030815"><br/>
    * 구성 요소
        | 요소 | 설명 |
        |:---:|------|
        | Scheme | 웹 브라우저가 웹 서버에 접속할 때 어떤 통신 규약(프로토콜)을 사용할 지 지정함 <br/> - 일반적으로 http/https를 사용하며 해당 프로토콜에 대한 정보는 아래 **HTTP/HTTPS** 부분을 참고 |
        | Authority | Host와 Port로 구분됨 <br/> - **Host**: 접속할 웹 서버의 호스트(서버 주소)에 대한 정보 <br/> &nbsp;&nbsp;&nbsp;&nbsp; → 도메인(Domain)이나 IP Address가 호스트로 사용될 수 있음 <br/> - **Port**: 접속할 웹 서버의 포트에 대한 정보 |
        | Path | 접속할 웹 서버의 경로에 대한 정보(= 웹 브라우저가 연결하려고 하는 리소스에 대한 정보) <br/> &nbsp;&nbsp; - ```/``` 문자로 구분됨 |
        | Query | 웹 브라우저가 서버에게 전달하는 파라미터 (추가적인 정보) <br/> &nbsp;&nbsp; - ```?``` 문자 뒤에 붙으며 일반적으로 ```파라미터명=인자값``` 형식으로 되어 있음 |
        | Fragment | 메인 리소스(페이지) 내에 존재하는 서비 리소스에 접근할 때 이를 식별사기 위한 정보를 담고 있음 <br/> &nbsp;&nbsp; - 웹 브라우저만 가지고 있는 데이터 <br/> &nbsp;&nbsp; - URL에서 ```#``` 문자 뒤에 붙음 |

<br/><br/>

### Encoding (인코딩)
문자 또는 기호 등의 정보, 형태를 표준화, 보안 등의 목적으로 다른 형태나 형식으로 변환하는 처리 혹은 그 처리 방식
* Decoding (디코딩) → Encoding의 반대 개념
    - 인코딩된 데이터를 원래 형태로 변환하는 것 (📌 Encoding과 Decoding에 사용된 방식은 동일해야 함)

<br/>

* 웹에서 사용하는 대표적인 인코딩
    - **URL Encoding** (percent encoding)
        + URI 구조체 내에서 예약어(구분자)로 사용되는 문자들을 전송하고자 할 때 사용함
            - ⚠️ 예약어는 URI 구조 내에서 문법적으로 중요한 의미를 가지고 있음 → ***문법적으로 사용하지 않을 경우에는 반드시 인코딩해 사용해야 함***
        + 인코딩 방식
            + 입력된 문자를 ASCII 테이블에서 매칭되는 Hex 값 앞에 ```%``` 문자를 붙여 인코딩할 수 있음
        + 예시: ```?```, ```#```, ```&```, ```=``` 문자의 URL Encoding
            | 문자 | URL Encoding |
            |:---:|:---:|
            | ```?``` | ```%3F``` |
            | ```#``` | ```%23``` |
            | ```&``` | ```%26``` |
            | ```=``` | ```%3D``` |
    - **HTML entity Encoding**
        + HTML 문서 내에서 사용하는 문자들이 <U>HTML에서 사용하는 태그로 인식하지 않도록 하기 위해서</U> 사용함
        + 인코딩 방식
            | 분류 | 설명 |
            |:---:|------|
            | Entity name encoding | 주요한 문자들의 경우 지정되어 있는 Entity name을 사용하여 인코딩할 수 있음 |
            | Entity number encoding | 입력된 문자를 ASCII 테이블에서 매칭되는 Hex 값 앞에 ```&#x```를 붙여 인코딩함 |
        + 예시: ```&```, ```<```, ```>``` 문자의 HTML entity Encoding
            | 문자 | Entity name encoding | Entity number encocding |
            |:---:|:---:|:---:|
            | ```&``` | ```&amp;``` | ```&#x26;``` |
            | ```<``` | ```&lt;``` | ```&#x3C;``` |
            | ```>``` | ```&gt;``` | ```&#x3E;``` |

<br/>

> * 💡 **인코딩**(Encoding)과 **암호화**(Encryption)의 비교
>   | | 비교 |
>   |:---:|------|
>   | 인코딩 | 알고리즘이 모두 공개되어 있고 키와 같은 요소가 포함되어 있지 않음 <br/> &nbsp;&nbsp; → ***모두가 원래의 정보로 복원이 가능함*** |
>   | 암호화 | 양방향 암호 알고리즘 <br/> &nbsp;&nbsp; → ***일치한 알고리즘과 유효한 키를 가지고 있다면 원래의 정보로 복원이 가능함***

<br/><br/>

### HTTP / HTTPS
URI의 구성 요소 중 Scheme(Protocol)에 해당함
* 프로토콜(Protocol): 컴퓨터 내부 혹은 컴퓨터 간에 정보를 원활하게 교환하기 위해 정한 여러 가지 통신 규칙과 방법에 대한 약속 또는 규약
    - 인터넷에서의 프로토콜: 두 컴퓨터 간의 서로 다른 방식을 연결하여 통신할 수 있도록 정한 공통의 규약
    - 프로토콜의 3가지 구성 요소
        | 요소 | 설명 |
        |:---:|------|
        | 구문 (Syntax) | 데이터의 형식이나 신호로, 부호/방법을 정의함 |
        | 의미 (Semantics) | 정확한 정보 전송을 위한 전송 제어와 오류 제어 방법을 정의함 |
        | 순서(Timing) | 송신자와 수신자 간 혹은 양단(End-to-End)의 통신 시스템, 망 사이의 통신 속도 및 순서를 정의함 |
    - 프로토콜에 대한 상세한 설명은 RFC(Request for Comments) 문서를 통해 공개됨

<br/>

* HTTP (Hyper Text Transfer Protocol)
    - 서버와 클라이언트의 데이터 교환을 **요청**(Request)와 **응답**의 형식으로 정의한 프로토콜
        + 웹 클라이언트가 웹 서버에 웹 페이지를 어떻게 요청하는지와 서버가 클라이언트로 어떻게 웹 페이지를 전송하는지를 정의함
    - HTTP의 기본 메커니즘 → "**클라이언트가 서버에 요청하면, 서버가 이에 응답함**"
    - HTTP의 기본 연결
        | 순서 | 설명 |
        |:---:|------|
        | 1 | ***Connect*** (Client → Server) <br/> 클라이언트가 웹 브라우저를 이용하여 서버에 연결을 요청하면 서버는 요청한 클라이언트에 대해 서비스를 준비함 |
        | 2 | ***Request*** (Client → Server) <br/> 클라이언트가 읽고자 하는 문서를 서버에 요청함 |
        | 3 | ***Response*** (Server → Client) <br/> 서버는 요청한 문서를 클라이언트로 전달 |
        | 4 | ***Close*** <br/> 연결을 종료함
    - HTTP 메시지
        + 클라이언트가 전송하는 <U>HTTP Request(요청)</U>와 서버가 반환하는 <U>HTTP Response(응답)</U>가 있음
        + HTTP 메시지의 구성
            | 구성 | 설명 |
            |:---:|------|
            | HTTP Head | 가장 첫 번째 줄인 **시작줄**(Start-line)과 그 뒤의 나머지 모든 줄에 해당하는 **헤더**(Header)로 구성됨 <br/> &nbsp;&nbsp; - 각 줄은 CRLF로 줄 바꿈이 이뤄져야 함 | 
            | HTTP Body | 헤드의 끝을 나타내는 CRLF 뒤의 모든 줄을 의미함 <br/> 클라이언트나 서버에게 전송하려는 데이터가 담겨 있음 |

<br/>

* HTTP Request (서버에 대한 요청)
  <br/><br/>
  <img width="2559" alt="HTTP Request" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/5a5b5ee4-ba25-4904-9943-1a3fca0afb2b"><br/>

    - 구성 요소
        | 구성 | 설명 |
        |:---:|------|
        | Method | 사용자가 서버에 요청 시 수행하고자 하는 동작 *← 시작줄의 첫 번째 요소* |
        | Path | 사용자가 서버에 요청하는 웹 리소스의 경로 *← 시작줄의 두 번째 요소* |
        | Version | 사용하는 HTTP의 버전 *← 시작줄의 세 번째 요소* |
        | Header | 서버에 추가 정보를 전달하는 데이터 부분 <br/> &nbsp;&nbsp; - ```필드: 값``` 형식으로 구성되며, 사용자와 서버가 상호작용하기 위한 정보를 담는 부분으로 사용됨 <br/> &nbsp;&nbsp;&nbsp;&nbsp; - *e.g. 사용자 데이터의 처리 방식 및 형식에 대한 정보, 서버에서 사용자를 식별하기 위한 쿠키 정보 등* <br/> - ❗️ 상황에 따라 많은 데이터가 포함될 수 있기 때문에 Header의 끝은 CRLF를 한 번 더 출력함 |
        | Body | Header의 끝을 나타내는 CRLF 뒤의 모든 줄을 의미하며, 서버에게 전송하려는 데이터가 담겨 있음 |
    - Method의 종류
        | 메소드 | 설명 |
        |:---:|------|
        | **OPTIONS** | 요청하는 리소스가 허용하는 메소드 목록을 반환함 |
        | **HEAD** | GET 메소드와 동일하지만, Response의 Body 부분은 받지 않고 Header만 받음 <br/> &nbsp;&nbsp; - 서버의 상태 확인 등의 목적으로 사용됨 |
        | **GET** | 리소스를 요청함 <br/> &nbsp;&nbsp; - 요청 데이터에 대한 인수를 URL를 통해 전송함 → 주소만 알아도 연결된 페이지의 내용을 알 수 있음 |
        | **POST** | 특정 리소스 생성 및 데이터 추가를 위해 값을 제출할 때 사용함  <br/> &nbsp;&nbsp; - 전송할 데이터는 보통 HTTP 바디에 포함되며, URL를 통해 인숫값을 전송하지 않음 <br/> &nbsp;&nbsp;&nbsp;&nbsp; ***→ 다른 사람이 주소를 통해 해당 웹 페이지를 볼 수 없어 GET 방식보다 안전함*** |
        | **PUT** | 특정 리소스의 내용을 보낸 값으로 설정함 |
        | **PATCH** | 특정 리소스의 내용 중 보낸 값의 key만 변경함 |
        | **DELETE** | 특정 리소스를 삭제함 |
        | **TRACE** | 요청받은 값을 Response의 Body로 다시 클라이언트에게 되돌려줌 (루프백 검사용으로 사용됨) |
    - Header의 종류
        + 웹 해킹과 관련된 Request의 Header
            | Header | 설명 |
            |:---:|------|
            | **Host** | 데이터를 보내는 서버의 주소를 의미함 |
            | **Cookie** | 사용자를 식별하기 위해 사용하는 정보를 의미함 |
            | **User-Agent** | 사용자가 사용하는 프로그램의 정보를 의미함 |
            | **Referer** | 페이지 이동 시 이전 URI의 정보를 나타냄 |
            | **Content-Type** | 사용자가 전달하는 데이터의 처리 방식과 형식을 나타냄 <br/> (사용자와 서버 간의 데이터 처리 방식이 일치되어야 정상적으로 데이터 통신이 이루어짐) |
        + 이 외에도 HTTP에서 사용되고 있는 헤더들은 다양함 → 자세한 내용은 [mdn web docs: HTTP headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)를 참고


<br/>

* HTTP Response (사용자의 요청에 대한 서버의 응답)
  <br/><br/>
  <img width="2560" alt="HTTP Response" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/1785b50e-4e4a-488b-93ae-5502173b1251"><br/>

    - 구성 요소
        | 구성 | 설명 |
        |:---:|------|
        | **Version** | 사용하는 HTTP의 버전 *← 시작줄의 첫 번째 요소*
        | **Status Code** | 사용자의 요청에 대한 서버의 처리 결과(상태 응답 코드) *← 시작줄의 두 번째 요소* <br/> &nbsp;&nbsp; - 상태 코드를 나타내는 3자리 숫자 뒤에 처리 사유(Reason Phrase)가 기술되어 있음 |
        | **Header** | ```필드: 값```의 형태로 이루어지며, 사용자와 서버가 상호작용하기 위한 데이터를 담는 부분으로 사용됨 <br/> &nbsp;&nbsp; - *e.g. 사용자(웹 브라우저)에서 서버의 응답 데이터를 처리하는 방식 및 형식에 대한 정보, 서버에서* <br/> &nbsp;&nbsp;&nbsp;&nbsp;*사용자를 식별하기 위한 쿠키 발급 정보 등* |
        | **Body** | Header의 끝을 나타내는 CRLF 뒤의 모든 줄을 의미하며, 서버가 사용자에게 응답하는 데이터가 담겨 있음 |
    - Status Code의 종류
        + HTTP 표준에서는 대략 40여 개의 상태 코드를 정의하고 있으며, 각각은 첫 번째 자릿수에 따라 5개의 클래스로 분류됨
            | 상태 코드 | 설명 |
            |:---:|------|
            | 100번대 | ***정보 전송*** &nbsp; → &nbsp; 요청을 제대로 받았고, 처리가 진행 중임 (시험용 외에는 서버 쪽의 추가 응답이 없음) |
            | 200번대 | ***성공*** &nbsp; → &nbsp; 클라이언트의 요청이 성공적으로 수신되어 처리되었음을 의미함 <br/> - ***200 OK*** : 클라이언트의 요청이 성공했다는 것을 나타냄 <br/> - ***201 Created*** : 클라이언트의 PUT 요청이 성공적이라는 것을 나타냄 |
            | 300번대 | ***리다이렉션*** &nbsp; → &nbsp; 클라이언의 요청을 처리하기 위해서는 추가 동작을 취해야 함 (다른 곳의 자원이 필요함) <br/> - ***301 Moved Permanently*** : 브라우저의 요청을 다른 URI로 항시 전달한다는 것을 의미함 <br/> &nbsp;&nbsp;&nbsp;&nbsp; (다른 URI에 대한 정보는 **Location 헤더**에 있음) <br/> - ***302 Found*** : 요청한 리소스의 URI가 일시적으로 변경되었음을 의미함 <br/> &nbsp;&nbsp;&nbsp;&nbsp; (일시적으로 변경된 URI에 대한 정보는 **Location 헤더**에 있으며, 다음 요청 시에는 기존 URI로 돌아감) <br/> - ***304 Not Modified*** : 응답의 캐시된 버전이 여전히 유효함을 의미함 = 응답이 수정되지 않음 <br/> &nbsp;&nbsp;&nbsp;&nbsp; (**If-Modified-Since**, **If-None-Match** 요청 헤더를 활용해 캐시가 최근의 것인지 확인함)  |
            | 400번대 | ***클라이언트 측 에러*** &nbsp; → &nbsp; 클라이언트가 잘못된 요청을 보내어 처리에 실패함 <br/> - ***400 Bad Request*** : 클라이언트가 서버에 잘못된 요청을 했다는 것을 나타냄 <br/> - ***401 Unauthorized*** : 서버가 클라이언트의 요청에 대해 인증 확인을 요구함 <br/> - ***403 Forbidden*** : 클라이언트의 요청에 대해 접근을 차단함 <br/> - ***404 Not Found*** : 클라이언트가 서버에 요청한 자료가 존재하지 않음 <br/> - ***405 Method Not Allowed*** : 요청에 이용한 메소드는 해당 URI에 지원하지 않음을 의미함 <br/> - ***413 Payload Too Large*** : 요청 바디가 서버에서 처리하기에 너무 크다는 것을 의미함|
            | 500번대 | ***서버 측 에러*** &nbsp; → &nbsp; 클라이언트의 요청은 유효하지만, 서버에 에러가 발생하여 처리에 실패함 <br/> - ***500 Internal Server Error*** : 서버가 클라이언트의 요청을 실행할 수 없을 때 발생함 <br/> - ***503 Service Unavailable*** : 서버가 과부하로 인해 요청을 처리할 수 없음 |
        - ⚠️ <U>*웹 해킹에서 사용자의 입력에 의한 서버의 응답을 주목해야 함*</U>
    - Header의 종류
        + 웹 해킹과 관련된 Response의 Header
            | Header | 설명 |
            |:---:|------|
            | **Content-Type** | 서버의 응답 데이터를 웹 브라우저에서 처리할 방식과 형식을 나타냄 |
            | **Content-Length** | 서버가 사용자에게 응답해주는 데이터의 길이를 나타냄 |
            | **Server** | 서버가 사용하는 소프트웨어의 정보를 나타냄 |
            | **Allow** | 허용되는 Method 목록을 사용자에게 알려줄 때 사용함 (**OPTIONS** 메소드로 요청 시) |
            | **Location** | 300번 영역의 응답 코드 사용 시 변경된 웹 리소스의 주소를 나타냄 |
            | **Set-Cookie** | 사용자에게 쿠키를 발급할 때 사용함 <br/> (해당 헤더를 받은 웹 브라우저는 해당 쿠키를 저장함) |

<br/>

* HTTP와 HTTPS의 비교
  <br/><br/>
  <img width="2560" alt="HTTP, HTTPS 비교" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/6a925969-4636-4b49-bc15-fbd1d0e14b12"><br/>
  
    | | 설명 |
    |:---:|------|
    | HTTP | ***Hyper Text Transfer Protocol*** → 📌 HTTP 사용 시 웹 서버의 URL이 ```http://```로 시작함 <br/> 📌 <U>TCP를 전송 프로토콜로 사용해 통신하며, 기본 포트로 80을 사용함</U> <br/> 네트워크 상에서 모든 데이터를 암호화되지 않은 평문으로 통신을 함 <br/> &nbsp;&nbsp; - 상위 네트워크 장비나 같은 네트워크 상의 MITM 공격 등으로 인해 통신이 노출될 경우 평문 정보가 그대로 노출됨 <br/> &nbsp;&nbsp;&nbsp;&nbsp; → 민감한 정보가 노출되어 심각한 위험을 초래할 수 있음 |
    | HTTPS | ***HTTP over Secure socket layer*** → 📌 HTTPS 사용 시 웹 서버의 URL이 ```https://```로 시작함 <br/> 📌 <U>TLS를 전송 프로토콜로 사용해 통신하며, 기본 포트로 443을 사용함</U> <br/> Transport Layer Security(TLS), Secure Sockets Layer(SSL)를 사용해서 암호화함 <br/> &nbsp;&nbsp; - 네트워크 상에서 모든 데이터들일 공개키 암호화를 사용해서 암호화되어 전달됨 (HTTP의 문제점인 **데이터의 평문 전송**을 보완함) <br/> &nbsp;&nbsp;&nbsp;&nbsp; → 중간에 통신이 노출되거나 공격자가 탈취한다고 하더라도 이를 해석하는 것이 불가능하기 때문에 비교적 안전함 <br/> &nbsp;&nbsp; - ⚠️ 공격자가 중간에서 스니핑을 하기는 어렵게 만들지만, <U>웹 애플리케이션의 중요 원인인 사용자 입력값에 대한 검증은 하지 못함</U> |
    - 현재 개발되는 서비스들은 규모에 상관없이 HTTPS를 사용하는 추세임
    - HTTP와 HTTPS의 핵심 구조 및 동작 원리는 동일하기 때문에 HTTP로 통칭하기도 함

<br/><br/>

### Cookie & Session
* HTTP → 하나의 Request와 Response의 쌍이 독립적으로 구성되어 통신하는 <U>connectionless, stateless 프로토콜</U>
    | HTTP 속성 | 설명 |
    |:---:|------|
    | ***connectionless*** 속성 | 하나의 요청에 하나의 응답을 한 후 네트워크 연결을 끝맺는 것 <br/> &nbsp;&nbsp; - 새 요청이 있을 때마다 항상 새로운 연결을 맺는다는 것을 의미함 <br/> &nbsp;&nbsp; - 불특정 다수의 사용자에게 서비스되어야 하는 웹의 특성상 계속해서 연결상태를 유지하는 것은 <br/> &nbsp;&nbsp;&nbsp;&nbsp; 서버 부하로 이어질 수 있기 때문에 connectionless 속성을 가지게 됨 |
    | ***stateless*** 속성 | 네트워크가 연결이 끝맺을 때 상태를 유지하지 않는 것 (통신이 끝난 후 상태 정보를 저장하지 않음) <br/> &nbsp;&nbsp; - 이전 통신에서 사용한 데이터를 다른 통신에서 요구할 수 없음을 의미함 <br/> &nbsp;&nbsp; - HTTP 요청마다 새로운 커넥션을 열기 때문에 사용자 인증을 계속해서 해야 한다는 단점이 있음 |
    + HTTP의 속성에 따른 단점 해결 방법
        | HTTP 속성 | 해결 방법 |
        |:---:|------|
        | connectionless 속성 | 최근에는 네트워크, 서버 등의 성능 향상으로 HTTP/1.1부터 **Keep-Alive**를 통해서 <U>일정 시간 동안 <br/>사용자와 서버가 계속 연결을 맺고 있는 방식</U>을 사용함 |
        | stateless 속성 | 상태를 유지하기 위한 **쿠키**(cookie)를 도입함 |

<br/>

* 쿠키(Cookie)
    | | 설명 |
    |:---:|------|
    | 정의 | 이용자가 인터넷 웹 사이트를 방문할 때 생성되는, ```key=value;``` 쌍으로 이뤄진 4KB 이하의 파일 <br/> &nbsp;&nbsp; - ```key=value;``` 뒤에 쿠키의 만료 시간, 접근할 수 있는 도메인 등 추가 옵션을 설정할 수 있음 |
    | 용도 | 클라이언트의 정보 기록과 상태 정보를 표현하는 용도로 사용함 |
    | 특징 | - **클라이언트에 저장되며, 설정 후에는 웹 브라우저가 자동으로 요청 헤더에 쿠키를 추가하여 전송함** <br/> &nbsp;&nbsp;&nbsp;&nbsp; → 클라이언트는 저장된 쿠키를 조회/수정/추가할 수 있음 <br/> &nbsp;&nbsp;&nbsp;&nbsp; → ⚠️ 이용자가 요청을 보낼 때 쿠키 헤더를 **변조**할 수 있음 <br/> - 쿠키 설정 시 <U>만료 시간</U>을 지정할 수 있음 <br/> &nbsp;&nbsp;&nbsp;&nbsp; - 만료 시간 이후에는 클라이언트에서 쿠키가 삭제되며, 쿠키의 만료는 클라이언트에서 관리됨 |
    - 쿠키를 이용한 상태 유지
        | 순서 | 설명 |
        |:---:|------|
        | 01 | 서버가 클라이언트에게 쿠키를 발급함 |
        | 02 | 클라이언트는 서버에 요청을 보낼 때마다 쿠키를 전송함 |
        | 03 | 서버는 클라이언트의 요청에 포함된 쿠키를 확인해 클라이언트를 구분할 수 있음 (클라이언트 신분 확인 가능) |
    - 웹 페이지에 쿠키를 적용하는 방법
        | 쿠키 설정 | 설명 |
        |:---:|------|
        | 서버 측 | **HTTP Response의 Set-Cookie Header**를 이용하여 쿠키를 설정함 ← ❗️ 일반적으로 서버가 쿠키를 설정함 <br/> &nbsp;&nbsp; - Response Header에 ```Set-Cookie: name=test;```가 있으면 쿠키를 설정한 것임 |
        | 클라이언트 측 | Javascript의 ```document.cookie```를 통해 데이터를 쿠키에 저장함 <br/> &nbsp;&nbsp; - ```document.cookie = "name=test;"```로 쿠키를 설정할 수 있음|
        + 📄 Chrome 브라우저: 클라이언트에서 쿠키를 확인하는 방법
            | 방법 | 설명 |
            |:---:|------|
            | Devtools의 Console 탭 | Console 탭에서 ```document.cookie```를 입력하면 쿠키 정보를 확인할 수 있음 |
            | Devtools의 Application 탭 | Application 탭의 왼쪽 목록에서 Cookies를 펼치면 Origin 별로 설정된 쿠키 정보를 <br/> 확인/수정할 수 있음 |
    - ⚠️ ***쿠키 변조***
        + 서버가 <U>별다른 검증 없이</U> 쿠키를 통해 이용자의 정보를 식별하는 경우 공격자는 쿠키 정보를 변조할 수 있음
            - 인증 상태가 쿠키에 저장되어 있음 → 쿠키 변조 시 타 이용자를 사칭해 정보를 탈취할 수 있음 <br/> &nbsp;&nbsp; ↳ 이는 쿠키가 클라이언트의 브라우저에 저장되고 클라이언트의 요청에 포함되는 정보이기 때문에 가능함
            - 이를 해결하기 위해 **세션**(Session)을 사용함

<br/>

* 세션(Session)
    | | 설명 |
    |:---:|------|
    | 정의 | 인증 정보를 서버에 저장하고 Session ID를 만들어 클라이언트에 전달하는 방식 <br/> &nbsp;&nbsp; - Session ID: 인증 정보에 접근할 수 있는, 유추할 수 없는 랜덤한 문자열 키 |
    | 사용 이유 | 쿠키에 인증 상태를 저장하지만 <U>클라이언트가 인증 정보를 변조할 수 없게 하기 위해</U> 사용함 |
    | 사용 방식 | 브라우저는 Session ID를 쿠키에 저장하고 이후에 HTTP 요청을 보낼 때 Cookie 헤더에 이 값을 넣음 <br/> → 서버는 요청에 포함된 Session ID에 해당하는 데이터를 가져와 인증 상태를 확인함 | 
    + Session ID가 쿠키에 국한되지 않고 localStorage(웹 브라우저의 저장 공간) 등 다양한 곳에 저장되어 사용될 수 있음

<br/><br/>

### Domain Name / Host Name
* URI의 구성 요소 중 Host → **웹 브라우저가 어디에 연결할지** 정함
    - Domain Name과 IP Address의 값을 가질 수 있음
        | | 설명 |
        |:---:|------|
        | IP Address | 네트워크 상에서 통신이 이루어질 때 장치를 식별하기 위해 사용되는 주소 <br/> &nbsp;&nbsp; - IPv4의 경우 32비트 값을, IPv6의 경우 128비트의 값을 가지며 불규칙한 숫자로 이루어져 있음 |
        | Domain Name | 도메인의 특성을 담은 이름 |
    - 📌 사람이 외우기 쉽고 의미를 부여하기 위해 일반적으로 Domain Name을 IP Address 대신 사용함

<br/>

* Domain Name
    - Domain Name 사용 시 Host 조회 방법
        | 순서 | 설명 |
        |:---:|------|
        | 01 | 브라우저는 입력받은 Domain Name을 DNS(Domain Name Server)에 질의함 |
        | 02 | DNS는 해당 Domain Name에 대한 IP Address 정보를 브라우저에게 전달함 |
        | 03 | 브라우저는 전달 받은 IP Address를 사용해 통신함 |
        + **Domain Name Server** (DNS): Domain Name과 IP Address 정보를 매핑하여 저장함
    - Domain Name 정보를 확인하는 방법
        - MacOS, Linux, Windows 모두 ```nslookup``` 명령어를 사용하여 확인할 수 있음

<br/><br/>

### 웹 서버 어플리케이션
<img width="2560" alt="웹 서버 어플리케이션" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/5b65938c-13cb-4887-a799-c4d2e81f02ec"><br/>

* Web Server (웹 서버)
    - 사용자의 HTTP 요청을 해석하여 처리한 후 응답하여 주는 역할을 함
        + 사용자로부터 받는 역할을 자체적으로 처리할지, 들어온 요청에 알맞은 내부 서비스로 연결할지를 정할 수 있음
            | 클라이언트가 접근한 URI 예시 | 설명 |
            |---|------|
            | **.html** 확장자를 가진 리소스 | 웹 서버에서 해당 경로의 html을 반환해 줌 |
            | **.php** 확장자를 가진 리소스 | php 엔진을 통해 해당 요청을 처리함 |
            | **/payment/** 경로로 시작하는 요청 | payment를 처리하기 위한 어플리케이션에 요청을 연결해주는 역할을 수행함 |
    - 대표적인 예시: Nginx, Apache, Tomcat, IIS 등

<br/>

* Web Application (웹 어플리케이션)
    - 사용자의 요청을 동적으로 처리할 수 있도록 만들어진 어플리케이션
        + 사용자가 요청한 내용을 동적으로 처라히기 위해 **Web Application Language**가 사용됨
            - PHP, NodeJS, Python, Java가 대표적이며, 이 외에도 굉장히 많은 언어가 존재함
            - Python의 django와 flask, Java의 Spring 등과 같이 웹 개발을 편리하게 해주는 프레임워크도 많이 존재함
    - ⚠️ 서버에서 동작하기 때문에 웹 어플리케이션 구현체에서 취약점이 발생하게 되면 서버에 직접적인 영향을 끼치게 됨

<br/>

* DataBase Management System(DBMS)
    - 데이터베이스 내의 데이터 조회﹒수정﹒삽입을 용이하게 할 수 있도록 도와주는 서버 어플리케이션
    - DBMS와 데이터베이스
        | | 설명 |
        |:---:|------|
        | 데이터베이스 | 해당 어플리케이션에서 관리하는 데이터 <br/> &nbsp;&nbsp; - 사용자의 인증, 상품, 문서 등 **중요한 개인 정보가 포함된** 여러 가지 내용이 존재함 → 보안에 각별히 신경써야 함 <br/> &nbsp;&nbsp; - 주로 많은 수의 데이터를 저장하거나 데이터 변경이 자주 일어나는 업무에 사용함 |
        | DBMS | MySQL, MS-SQL 등과 같이 데이터베이스의 내용을 조회﹒수정﹒삽입하기 위해 DBMS를 사용함 <br/> &nbsp;&nbsp; - RDBMS와 NRDBMS으로 그 종류가 나뉘며, 사용자의 입력값을 필터링 없이 사용할 경우 SQL/NoSQL Injection 공격에 <br/> &nbsp;&nbsp;&nbsp;&nbsp; 노출됨 |

<br/><br/><br/>

## Web Hacking 개요
