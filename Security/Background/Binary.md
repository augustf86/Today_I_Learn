# Background: Binary

* 프로그래밍 언어(Programming Language): 컴퓨터에 명령을 하기 위해 사용되는 언어 = 프로그램을 개발하기 위해 사용되는 언어
    | 언어 | 설명 |
    |:---:|------|
    | 기계어 <br/> (Machine Language) | 컴퓨터에 명령을 내리기 위해 정의된 최초의 언어 <br/> &nbsp;&nbsp; - 기계어를 이용해 필요한 연산을 컴퓨터가 대신하도록 명령을 내림 <br/> &nbsp;&nbsp; - 📌 **0과 1로 구성**되어 있어 사람들이 이해하기 어려웠음 → 기계어를 이용하는 것은 비효율적! |
    | 어셈블리어 <br/> (Assembly Language) | 기계어보다 사람이 이해하기 쉬운 언어 <br/> &nbsp;&nbsp; - 어셈블리어를 기계어로 번역해주는 어셈블러(Assembler)도 함께 개발됨 <br/> &nbsp;&nbsp; - 기계어에 비해면 효율적이지만, 여전히 규모가 큰 프로그램을 개발하기에는 부족했음 |
    | C, C++, Go, Rust 등 <br> 현대의 프로그래밍 언어 | 햔제 널리 사용되고 있는, 어셈블리어보다 더욱 사람이 이해하기 쉬운 언어 <br/> &nbsp;&nbsp; - 프로그래밍 언어들을 기계어로 번역해주는 컴파일러(Compiler)도 개발됨 <br/> &nbsp;&nbsp; - 📌 프로그램 개발의 효율을 극대화해줌 |
    - 프로그래밍 언어의 분류
        | 분류 | 설명 | 해당되는 언어 |
        |:---:|------|:---:|
        | 고급 언어 <br/> (High-Level Language) | 사람이 이해하기 쉬운 언어 | C, C++, Go, Rust 등 |
        | 저급 언어 <br/> (Low-Level Language) | 사람이 이해하기 어려운 언어 | 기계어, 어셈블리어 |
        + 생산성의 측면에서 고급 언어가 저급 언어보다 **압도적으로 효율적임** → 특별한 경우를 제외하고는 저급 언어로 프로그램을 개발하지 않음

<br/><br/>

## 프로그램(Program)
* 연산 장치가 수행해야 하는 동작을 정의한 일종의 문서
    - 프로그램을 연산 장치에 전달함 → CPU는 프로그램에 적혀 있는 명령들을 처리함 <br/> &nbsp;&nbsp; ⇒ 📌 *이러한 과정을 통해 프로그래머가 의도한 동작을 수행함*
    - *programmable*과 *non-programmable*
        | 용어 | 설명 |
        |:---:|------|
        | *programmable* | 사용자가 정의한 프로그램을 해석하여 명령어를 처리할 수 있는 연산 장치 <br/> &nbsp;&nbsp; - 현대의 컴퓨터가 대표적인 *programmable* 연산 장치임 |
        | *non-programmable* | *programmable*의 반대 개념 <br/> &nbsp;&nbsp; - 일반 계산기가 대표적인 *non-programmable* 연산 장치임 |
    - 프로그램 전달 방식
        | | 설명 |
        |:---:|------|
        | 과거 | 프로그램을 내부 저장 장치에 전달할 수 없었음 → 아래의 2가지 방식 중 하나를 선택해서 사용함 <br/> &nbsp;&nbsp; - 방법1: 사람이 전선을 연결하여 컴퓨터에 전달함 (→ 애니악(ENIAC)) <br/> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; → 프로그램이 바뀔 때마다 배선을 재배치해야 했으므로 매우 비효율적임 <br/> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; → 크기가 큰 프로그램을 사용하기도 어려웠음 <br/> &nbsp;&nbsp; - 방법2: 천공 카드(Punched card)에 프로그램을 기록하여 재사용함
        | 1950년 경 이후 | **Stored-Program Computer**가 최초로 상용화됨 <br/> &nbsp;&nbsp; - 프로그램을 메모리에 전자적으로, 또는 광학적으로 저장할 수 있음 → 많은 이점이 존재함 <br/> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + 기존의 컴퓨들보다 월등히 많은 프로그램을 저장할 수 있음 <br/> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + 저장된 프로그램을 사용하는 것도 간편함 <br/> &nbsp;&nbsp; - 📌 현재 컴퓨터의 대부분이 **Stored-Program Computer**의 형태로 개발됨 |
* ❓ 엔지니어들이 프로그램을 **바이너리**(Binary)라고 부르는 이유 <br/> &nbsp;&nbsp; → **Stored-Program Computer**에서 프로그램이 저장 장치에 이진(Binary) 형태로 저장되기 때문
    - 텍스트가 아닌 다른 데이터들도 바이너리가 볼리긴 하지만, **많은 경우에 바이너리는 프로그램을 의미함**

<br/><br/>

## 컴파일(Compile)
* 컴파일(Compile): 프로그래밍 언어로 작성된 소스 코드를 컴퓨터가 이해할 수 있는 기계어의 형식으로 번역하는 것
    - 컴파일 관련 용어
        | 용어 | 설명 |
        |:---:|------|
        | 소스 코드 (Source Code) | CPU가 수행해야 하는 명령들을 프로그래밍 언어로 작성한 것 |
        | 컴파일러(Compiler) | 컴파일을 수행하는 소프트웨어 <br/> &nbsp;&nbsp; - GCC, Clang, MSVC 등이 대표적 |
    - 📌 한 번 컴파일되면 결과물이 프로그램으로 남음 → 언제든지 이를 실행하여 같은 명령을 처리하게 할 수 있음
    - ⚠️ **Python, Javascript 등과 같이 모든 프로그래밍 언어가 컴파일을 필요로 하는 것은 아님**

<br/>

* **인터프리팅**(Interpreting): 사용자의 입력, 또는 사용자가 작성한 스크립트를 그때 그때 번역하여 CPU에 전달하는 것
    - 인터프리팅을 처리해주는 프로그램을 **인터프리터**(Interpreter)라고 함

<br/> 

* 컴파일과 인터프리팅의 비교
    | | 비교 |
    |:---:|------|
    | 컴파일 <br/> (Compile) | 아무 배경지식이 없는 사람이 책을 읽을 수 있도록 배경지식을 엮고, 번역하여 **하나의 번역본**을 만드는 과정에 비유할 수 있음 <br/> &nbsp;&nbsp; - 결과물이 남아서 언제든 다시 읽어볼 수 있지만, 한 번 번역하는 데 시간이 많이 필요함 |
    | 인터프리팅 <br/> (Interpreting) | 동시 통역사를 거쳐 대화하는 것에 비유할 수 있음 <br/> &nbsp;&nbsp; - 상대방과 빠르게 의사소통할 수 있지만, 같은 내용이라도 매번 통역을 거쳐야 한다는 단점이 있음 |

<br/>

### 컴파일 과정
* 컴파일 과정 설명 시 사용할 예제 코드(C 언어, 리눅스 환경에서 GCC 컴파일러 이용)
    - add.C
        ```c
        // Name: add.c

        #include <stdio.h>

        #define HI 3

        int add(int a, int b) {return a + b + HI; } // return a + b
        ```
    - add.h
        ```c
        // Name: add.h

        int add(int a, int b);
        ```

<br/>

#### [1] **전처리** (Preprocess)
* 전처리(Preprocessing): 컴파일러가 소스 코드를 어셈블리어로 컴파일하기 전에, 필요한 형식으로 가공하는 과정
    - 전처리 과정 (언어마다 조금씩 차이는 있음)
        | 순서 | 설명 |
        |:---:|------|
        | 1. 주석 제거 | 주석(Comment): 개발자가 자신과 개발자들의 코드 이해를 돕기 위해 작성하는 메모 (```\\```는 C의 한 줄 주석을 의미함) <br/> &nbsp;&nbsp; → 프로그램의 동작과 상관이 없으므로 전처리 단계에서 모두 제거됨 |
        | 2. 매크로 치환 | 매크로: 자주 쓰이는 코드나 상수 값을 단어로 정의한 것 (```#define```으로 정의함) <br/> &nbsp;&nbsp; → 전처리 과정에서 매크로의 이름은 값으로 치환됨 |
        | 3. 파일 병합 | 일반적인 프로그램은 여러 개의 소스(```.c``` 확장자)와 헤더 파일(```.h``` 확장자)로 이루어져 있음 <br/> &nbsp;&nbsp; → 이를 따로 컴파일해 합치기도 하지만, 어떠한 경우는 전처리 단계에서 파일을 합치고 컴파일함 |
* 예제 코드 전처리 결과 (```gcc -E add.c > add.i```)
  <br/><br/>
  <img width="2560" alt="전처리" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/64c50d2f-af72-4760-9e59-4b87cac602b4"><br/>
  
<br/>

#### [2] **컴파일** (Compile)
* 컴파일(Compile): C로 작성된 소스 코드를 어셈블리어로 번역하는 것
    | 특징 | 설명 |
    |----|------|
    | 소스 코드의 문법을 검사 | 컴파일 과정에서 코드에 문법적 오류가 발견된다면 컴파일을 멈추고 에러를 출력함 |
    | 최적화 기술 적용 | 코드를 번역할 때 몇몇 조건을 만족하면 최적화 기술을 적용하여 효율적인 어셈블리 코드를 생성해줌 <br/> &nbsp;&nbsp; - 최적화 기술 적용 효과 <br/> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + 사용자가 작성한 소스 코드와 연산 결과가 동일한, 더 짧고 실행 시간도 단축되는 어셈블리 코드를 생성함 |
    + gcc 컴파일러의 최적화 옵션
        - ```-O```: 최적화의 전체 적인 수준을 제어함 → 최적화 레벨이 올라갈수록 컴파일 실행 시간과 메모리 소비율이 증가함
            | 최적화 옵션 | 설명 |
            |:---:|------|
            | ```-O0``` | 어떤 최적화도 수행하지 않음 (최적화 옵션을 주지 않는 것과 동일함)
            | ```-O0```, ```-O``` | 1단계 수준의 최적화 → 코드의 크기와 실행 시간이 감소됨 |
            | ```-O2``` | 메모리 공간과 속도의 희생을 제외하고 최적화<br/> &nbsp;&nbsp; - loop unrolling, function inlining에 대한 최적화는 수행하지 않음 |
            | ```-O3``` | ```-O2``` 최적화에 인라인 함수와 레지스터에 대한 최적화를 추가로 수행함|
            | ```-Os``` | 사이즈 최적화를 수행함(```-O2```와 동일한 수준의 최적화를 사용하지만, 코드의 크기를 증가시키지 않음) <br/> &nbsp;&nbsp; → 임베디드 시스템과 같이 메모리 공간이 협소한 곳에서 주로 사용됨 |
            | ```-Ofast``` | 최고 수준의 최적화를 수행함 <br/> &nbsp;&nbsp; - 컴파일하는 속도가 가장 느림 <br/> &nbsp;&nbsp; - ⚠️ 컴파일된 코드의 C 표준 호환성이 떨어질 수 있으므로 주의해야 함 (**사용을 권장하지 않음**)|
            | ```-Og``` | 디버깅에 혼란을 주는 최적화 기능을 제거함 |
        - EX: opt.c 코드를 ```-O2``` 옵션으로 최적화하여 컴파일
          <br/><br/>
          <img width="2560" alt="최적화" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/b19926be-fe3a-4eb7-8fba-bc997af45528"><br/><br/>
* 예제 코드 컴파일 결과 (```gcc -S add.i -o add.S```)
  <br/><br/>
  <img width="2560" alt="컴파일" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/ca75d509-44df-46b2-ae4c-8c6ae6894a34"><br/>

<br/>

> * 💡 **컴파일 과정 속 컴파일**
>   - 컴파일(Compile)의 정확한 의미: 어떤 언어로 작성된 **소스 코드(Source Code)를 다른 언어의 목적 코드(Object Code)로 번역**하는 것 <br/> &nbsp;&nbsp; → 소스 코드를 어셈블리어로, 또는 소스 코드를 기계어로 번역하는 것 모두 컴파일이라고 할 수 있음

<br/>

#### [3] **어셈블** (Assemble)
* 어셈블(Assemble): 컴파일로 생성된 어셈블리어 코드를 ELF 형식의 목적 파일(Object File)로 변환하는 과정
    - 운영체제에 따른 목적 파일의 형식
        | 운영 체제(OS) | 목적 파일의 형식 (*→ 해당 OS의 실행 파일 형식*) |
        |:---:|:---:|
        | 리눅스 | ELF 형식 |
        | 윈도우 | PE 형식 |
    - 목적 파일로 변환되고 나면 어셈블리 코드가 기계어로 번역됨 → 사람이 이를 해석하기 어려워짐
* 에제 코드 어셈블 결과 (```gcc -c add.S -o add.o```)
  <br/><br/>
  <img width="2560" alt="d어셈블" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/16bbe185-ad73-4cb5-9d27-3d0c60a4a9d6"><br/>

<br/>

#### [4] **링크** (Link)
* 링크(Link): 여러 목적 파일들을 연결하여 실행 가능한 바이너리로 만드는 과정
    - 링크가 필요한 이유
      <br/><br/>
      <img width="2560" alt="링크가 필요한 이유" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/3dc44edf-afbf-4c51-9433-993560d9e05e"><br/><br/>
* 예제 코드 링크 결과
  <br/><br/>
  <img width="2560" alt="링크" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/f9f641f4-e316-4985-a74a-9a443b7dc827">

<br/><br/>

## 디스어셈블과 디컴파일
* 디스어셈블(Disassemble): 어셈블의 역과정 → 기계어을 어셈블리어로 변환(재번역)하는 과정
    - ❓ 디스어셈블 과정이 필요한 이유 <br/> : 바이너리를 분석하려면 바이너리를 읽을 수 있어야 하는데, 컴파일된 프로그램의 코드는 기계어로 작성되어 있어 그 자체로 이해하기 어렵기 때문
    - ```objdump -d``` 명령어로 쉽게 디스어셈블된 결과를 확인할 수 있음
      <br/><br/>
      <img width="2560" alt="디스어셈블" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/5fab7769-1423-4349-a0cd-b4f64f1cf921"><br/>

<br/>

* 디컴파일(Decompile): 컴파일의 역과정 → 기계어를 고급 언어로 번역하는 과정
    - 디컴파일러(Decompiler)의 개발 배경
    - 디스어셈블러와 디컴파일러의 비교
        | | 비교 설명 |
        |:---:|------|
        | 디스어셈블러 | 어셈블리어와 기계어는 거의 일대일로 대응됨 → 오차없는 디스어셈블러를 개발할 수 있었음 |
        | 디컴파일러 | 고급 언어와 어셈블리어 사이에는 대응 관계가 없음 → ⚠️ 일반적으로 바이너리의 소스 코드와 동일한 코드를 생성할 수 없음 <br/> &nbsp;&nbsp; - 코드를 작성할 때 사용했던 변수나 함수의 이름 등이 컴파일 과정에서 전부 사라짐 <br/> &nbsp;&nbsp; - 코드의 일부분은 최적화와 같은 이유로 컴파일러에 의해 완전히 변형됨 <br/> ⇒ **오차가 바이너리의 동작을 왜곡하지는 않으며, 디스어셈블러를 사용하는 것보다 압도적으로 분석 효율을 높여주기 때문에 <br/> &nbsp;&nbsp;&nbsp;&nbsp; 사용할 수 있다면 반드시 디컴파일러를 사용하는 것이 유리함!**|

<br/><br/><br/><br/>
### 🔖 출처
* [드림핵 Reverse Engineering] 📌 [Background: Binary](https://dreamhack.io/lecture/courses/67)
