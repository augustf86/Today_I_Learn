# Background: Computer Architecture

* 컴퓨터는 각자 다른 기능을 수행하는 여러 부품들의 도움으로 작동함
    - 컴퓨터를 구성하는 부품들의 예시
        | 부품 | 설명 |
        |:---:|------|
        | CPU | 컴퓨터의 작동에 핵심이 되는 **연산**을 처리함 |
        | 저장장치 | 데이터를 저장함 |
        | GPU | 그래픽 데이터를 처리함 |
        | 랜커드 | 네트워크 통신 처리에 특화되어 있음 |
        | 사운드 카드 | 소리 데이터를 처리함 |
        + 각 부품들은 특징이 뚜렷하여 컴퓨터에서 고유의 기능을 처리함
* 📌 **컴퓨터 구조**(Computer Architecture): 컴퓨터에 대한 기본 설계
    - 컴퓨터 구조가 존재하기 때문에 서로 다른 부품들이 모여서 '컴퓨터'라는 하나의 기계로서 작동할 수 있음
        + 컴퓨터의 기본 설계에 맞춰서 여러 하드웨어가 개발됨 → 이 하드웨어들을 조립하여 컴퓨터를 완성함
    - **명령어 집합구조**(Instruction Set Architecture, ISA): 전체적인 컴퓨터의 구조 중에서 특히 **CPU가 사용하는 명령어와 관련된 설계**
        + 가장 널리 사용되는 ISA 중 하나가 인텔의 **x86-64 아키텍처**

<br/><br/>

## 컴퓨터 구조(Computer Architecture)
컴퓨터가 효율적으로 작동할 수 있도록 하드웨어 및 소프트웨어의 기능을 고안하고, 이들을 구성하는 방법
* 컴퓨터의 기능 구조에 대한 설계, 명령어 집합구조(ISA), 마이크로 아키텍처, 기타 하드웨어 및 컴퓨팅 방법에 대한 설계 등이 포함됨
    | 분야 | 설명 |
    |:---:|------|
    | 컴퓨터의 기능 구조에 <br/>대한 설계 | 컴퓨터가 연산을 효율적으로 하기 위해 어떤 기능들이 컴퓨터에 필요한지 고민하고, 설계하는 분야 <br/> &nbsp;&nbsp; - 대표적으로 폰 노이만 구조, 하버드 구조, 수정된 하버드 구조가 있음 |
    | 명령어 집합 구조 <br/> (ISA) | CPU의 명령어에 대한 설계 → CPU가 처리해야 하는 명령어를 설계하는 분야 <br/> &nbsp;&nbsp; - 대표적으로 ARM, MIPS, AVR, 인텔의 x86 및 x86-64 등이 있음 |
    | 마이크로 아키텍처 <br/>(Micro Architecture) | CPU의 하드웨어적 설계 → 정의된 명령어 집합을 효율적으로 처리할 수 있도록 CPU의 회로를 설계하는 분야 <br/> &nbsp;&nbsp; - 캐시 설계, 파이프라이닝, 슈퍼 스칼라, 분기 예측, 비순차적 명령어 처리 등이 있음 |

<br/>

### 폰 노이만 구조
연산, 제어, 저장의 3가지 핵심 기능으로 구성된 구조
<br/><br/>
<img width="2560" alt="폰 노이만 구조" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/c0f0df69-98d6-4dbf-9fdb-46c8de3d5fa4">
<br/>
* 중앙처리장치(Central Processing Unit, CPU)
    - 프로그램의 연산을 처리하고 시스템을 제어하는 컴퓨터의 두뇌
        + 프로세스의 코드를 불러오고, 결과를 저장하는 일련의 모든 과정이 CPU에서 일어남
    - CPU의 구성 요소
        | 구성 요소 | 기능 |
        |:---:|------|
        | 산술논리장치<br/>(Arithmetic Logic Unit, ALU) | 산술/논리 연산을 처리함 |
        | 제어장치 <br/>(Control Unit, CU) | CPU를 제어함 |
        | 레지스터<br/>(Register) | CPU에 필요한 데이터를 저장함 |
        + ❓ CPU 내에 저장장치인 레지스터와 캐시를 가지고 있는 이유: **데이터의 교환 속도를 획기적으로 단축하기 위함**
            - CPU는 굉장히 빠른 속도로 연산을 처리하는데, 이를 위해 **데이터의 빠른 교환**이 필요함 <br/> &nbsp;&nbsp; = CPU는 필요한 데이터를 바르게 공급하고 반출할 수 있어야 장치의 효율을 제대로 발휘할 수 있음
                + CPU의 연산 속도는 주기억 장치 및 보조기억장치와의 데이터 교환 속도보다 압도적으로 빠름 → ⚠️ **이들만 사용하면 병목 현상이 발생함!**

* 기억장치(Memory)
    - 컴퓨터가 동작하는데 필요한 여러 데이터를 저장하기 위해 사용됨
    - 용도에 따른 기억장치의 분류
        | 분류 | 설명 |
        |:---:|------|
        | 주기억장치 | 프로그램의 실행과정에서 필요한 데이터를 임시로 저장하기 위해 사용됨 <br/> &nbsp;&nbsp; - 대표적으로 RAM(Random-Access Memory)이 있음 |
        | 보조기억장치 | 운영 체제, 프로글매 등과 같은 데이터를 장기간 보관하고자 할 때 사용됨 <br/> &nbsp;&nbsp; - 대표적으로 하드 드라이브(Hard Disk Drive, HDD), SSD(Solid State Drive) 등이 있음 |
* 버스(Bus)
    - 컴퓨터 부품과 부품 사이 또는 컴퓨터와 컴퓨터 사이에 신호를 전송하는 통로
    - 버스의 종류
        | 종류 | 설명 |
        |:---:|------|
        | 데이터버스(Data Bus) | 데이터가 이동함 |
        | 주소 버스(Address Bus) | 주소를 지정함 |
        | 제어 버스(Control Bus) | 읽기/쓰기를 제어함 |
        + 이 외에도 랜선이나 데이터 전송을 목적으로 하는 소프트웨어, 프로토콜 등도 버스라고 불림

<br/>

### 명령어 집합 구조(Instruction Set Architecture, ISA)
CPU가 해석하는 명령어의 집합
* 기계어로 작성되어 있는 프로그램의 코드를 실행하면 이 명령어들을 CPU가 읽고 처리함
* ISA의 종류
    | 종류 | 설명 |
    |:---:|------|
    | 인텔의 <br/>x86-64 | 고성능 프로세서를 설계하기 위해 사용됨 <br/> → 이를 기반으로 한 CPU들은 많은 전력을 소모하고 발열도 상대적으로 심하기 때문에 <br/> &nbsp;&nbsp; 안정적으로 전력을 공급할 수 있고 냉각 장치를 구비하는데 공간 상의 부담이 크지 않는 **데스크톱이나 랩톱**에 적합함 |
    | ARM, MIP, AVR | 배터리를 사용하거나 크기가 작은 임베디드 장치들은 전력 소모와 발열이 적은 프로세서를 사용함 <br/> &nbsp;&nbsp; - 드론, 공유기, 인공지능, 스마트폰 등이 이에 해당됨 |
    - ❓ 다양한 ISA가 개발되고 사용되는 이유: **모든 컴퓨터가 동일한 수준의 연산 능력을 요구하지 않으며, 컴퓨팅 환경도 다양하기 때문**

<br/><br/>

## x86-64 아키텍처
인텔의 64비트 CPU 아키텍처 → 인텔의 32비트 CPU 아키텍처인 IA-32를 64비트 환경에서 사용할 수 있도록 확장한 것
* 대다수의 개인용 컴퓨터들은 인텔의 x64 아키텍처를 사용하고 있음

<br/>

### WORD
CPU가 이해할 수 있는 데이터의 단위
* n 비트 아키텍처에서 n의 의미 = CPU가 한 번에 처리할 수 있는 데이터의 크기 → *WORD*
* WORD의 크기는 **CPU가 어떻게 설계됐느냐**에 따라 달라짐
    - EX: 32비트 아키텍처 → 📌 **아래의 부품들로 구성된 CPU는 설계 상 32비트의 데이터만 처리할 수 있게 됨**
        | | 설명 |
        |:---:|------|
        | ALU | 한 번에 32비트 크기의 값을 연산할 수 있음 |
        | 레지스터 | 레지스터의 용량이 32비트 크기임 |
        | 버스 | 버스의 대역폭이 32비트 크기임 |
* WORD가 크면 유리한 점
    - 현대 PC가 대부분 64비트 아키텍처의 CPU를 사용하는 이유: CPU가 제공하는 가상 메모리(Virtual Memory)의 크기
        + 가상 메모리(Virtual Memory): CPU가 프로세스에게 제공하는 가상의 메모리 공간
        + 32비트 아키텍처와 64비트 아키텍처의 비교
            | 아키텍처 | 비교 설명 |
            |:---:|------|
            | 32비트 아키텍처 | 최대로 제공 가능한 가상 메모리의 크기: 4,294,967,296바이트(= 4기가바이트) <br/> → 일상적으로 사용하기에는 적절할 수 있지만, <br/> &nbsp;&nbsp;&nbsp;&nbsp; 많은 메모리 자원을 소모하는 전문 소프트웨어나 고사양의 게임 등을 실행할 때는 부족할 수 있음 |
            | 64비트 아키텍처 | 최대로 제공 가능한 가상 메모리의 크기: 이론상 16엑사바이트(= 16,777,216 테라바이트) <br/> → 일반적으로 이 용량은 완전한 사용이 불가능할 정도로 큰 크기임 <br/> &nbsp;&nbsp;&nbsp;&nbsp; ⇒ 📌 **가용한 메모리 자원이 부족해서 소프트웨어의 최고 성능을 낼 수 없다거나 소프트웨어의 실행이 <br/> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;불가능한 상황이 거의 발생하지 않음** |

<br/>

### x86-64 아키텍처: 레지스터
* 레지스터 → **다양한 용도로 사용됨**
    - CPU가 데이터를 빠르게 저장하고 사용할 때 이용하는 보관소
    - 산술 연산 장치에 필요한 데이터를 저장함
    - 주소를 저장하고 참조함
* x86-64 아키텍처의 레지스터 종류
    | 종류 | 설명 |
    |:---:|------|
    | 범용 <br/>레지스터 <br/> (General Register) | 📄 주용도는 있으나, 그 외의 다양한 용도로 사용될 수 있는 레지스터 <br/><br/> [**x86-64**] 각각의 범용 레지스터는 8바이트를 저장할 수 있으며, 부호 없는 정수를 기준으로 $2^{64}-1$까지의 수를 나타낼 수 있음 <br/> &nbsp;&nbsp; - 자주 쓰이는 범용 레지스터들의 주용도는 아래를 참고 <br/><br/><img width="2560" alt="범용 레지스터" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/c2ff6cd5-76f5-4b02-a162-0f38c67ce3b6"><br/> |
    | 세그먼트 <br/>레지스터 <br/> (Segment Register) | [**x86-64**] 16비트 크기를 가지는, 6가지의 세그먼트 레지스터(cs, ss, ds, es, fs, gs)가 존재함 <br/> &nbsp;&nbsp; - cs, ds, ss 레지스터: 코드 영역과 데이터, 스택 메모리 영역을 가리킬 때 사용됨 <br/> &nbsp;&nbsp; - 나머지 레지스터: 운영체제 별로 용도를 결정할 수 있도록 범용적인 용도로 제작됨 <br/><br/> 💡 **과거와 현재의 세그먼트 레지스터의 용도가 다름!** <br/> &nbsp;&nbsp; - 과거 IA-32, IA-16에서는 사용 가능한 물리 메모리의 크기를 키우려고 했음 <br/> &nbsp;&nbsp;&nbsp;&nbsp; (범용 레지스터의 크기가 작아서 사용 가능한 메모리의 주소 폭이 좁았기 때문) <br/> &nbsp;&nbsp; - 현재 x64에서는 사용 가능한 주소 영역이 굉장히 넓기 때문에 과거의 용도로는 거의 사용되지 않음 |
    | 명령어 <br/>포인트<br/> 레지스터 <br/> (Instruction Pointer Register) | 📄 일련의 기계어 코드들로 이뤄진 프로그램에서 **CPU가 어느 부분의 코드를 실행할 지 가리키는** 레지스터 <br/><br/> [x86-64] 명령어 포인터 레지스터로 8바이트 크기의 **rip**를 사용함 |
    | 플래그 <br/>레지스터 <br/> (Flag Register) | 📄 **프로세서의 현재 상태를 저장**하고 있는 레지스터 <br/> &nbsp;&nbsp; - 자신을 구성하는 여러 비트들로 CPU의 현재 상태를 표현함 <br/><br/> [x86-64] **RFLAGS**라고 불리는 64비트 플래그 레지스터가 존재함 (*→ 과거 16비트 플래그 레지스터가 확장된 것*) <br/> &nbsp;&nbsp; - 64비트인 RFLAGS는 최대 64개의 플래그를 사용할 수 있지만, **실제로는 20여 개의 비트만** 사용함 <br/><br/><img width="2560" alt="플래그 레지스터" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/09e793f4-7d88-49cc-8bf5-0e2e0d6101fe"><br/> |

<br/>

### 레지스터 호환
* 각 아키텍처의 6개 레지스터들 (동일 위치에 있는 레지스터들은 호환성을 가짐)
    | 아키텍처 | | | | | | | | | |
    |:------:|---|---|---|---|---|---|---|---|------|
    | IA-16 <br/> (16비트 크기의 레지스터) | ax | bx | cx | dx | si | di | sp | dp | IA-32 레지스터의 <br/>하위 16비트를 가리킴 |
    | IA-32 <br/> (32비트 크기의 레지스터) | eax | ebx | ecx | edx | esi | edi | esp | ebp | x86-64 레지스터의 <br/>하위 32비트를 가리킴 |
    | x86-64 <br/> (64비트 크기의 레지스터) | rax | rbx | rcx | rdx | rsi | rdi | rsp | rbp | |
    - x86-64 아키텍처의 6개 레지스터들은 IA-32의 6개 레지스터들의 확장된 형태로, 호환이 가능함
        + 📌 **IA-32의 6개 레지스터는 호환성을 위해 x86-64에서도 그대로 사용 가능**
    - IA-32 아키텍처의 6개 레지스터들은 IA-16의 6개 레지스터들의 확장된 형태로, 호환이 가능함

<br/><br/><br/><br/>
### 🔖 출처
* [드림핵 Reverse Engineering] 📌 [Background: Comptuer Architecture](https://dreamhack.io/lecture/courses/62)
