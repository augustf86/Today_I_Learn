# 블록 암호: DES (Data Encryption Standard)

* 미국의 국가 안보국(National Security Agency, NSA)에서 IBM의 루시퍼 알고리즘을 개량하여 만든 대칭키 암호
    - 128비트 키를 사용하던 루시퍼와는 달리 DES의 키 길이로 56비트를 사용하고, 내부에서 사용하는 알고리즘도 일부 변경함
    - 미국 국립표준기술연구소(National Institute of Standards and Technology, NIST)는 DES를 1976년부터 2002년까지 표준 블록 암호로 인정함
        + ⚠️ 현대에는 DES에 대한 공격 기법이 많이 연구되어 더 이상 블록 암호의 표준으로 사용하지 않음
* 8바이트(64비트)를 한 블록으로 하는 블록 암호
    - DES의 전체 구조
      <br/><br/>
      <img width="2560" alt="DES 전체 구조" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/5e8320bb-34f7-4799-b834-3b011effcfa6"><br/>


<br/><br/>

## DES의 원리
* 곱 암호(Product Cipher): 치환이나 순열 같은 단순한 연산들로 한 라운드를 구성하고, 각 라운드를 여러 번 반복하여 암호학적 안전성을 확보하는 암호
  <br/><br/><img width="2560" alt="product cipher" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/57075222-2200-4855-a7c8-2a64fad4a5cd"><br/><br/>
    - DES가 현대 암호 시스템의 두 가지 성질을 만족하기 위해 사용하는 연산들
        | 성질 | DES 연산 |
        |---|---|
        | 혼돈(Confusion) | 치환(Substitution) |
        | 확산(Diffusion) | 순열(Permutation) |
        + 치환과 순열은 매우 단순한 연산이므로 **평문에 이 연산들을 한 번 적용한다고 해서 암호학적 효과를 기대할 수 없음** <br/> &nbsp;&nbsp; 📌 치환과 순열을 여러 번 교차해서 반복 적용히면 혼돈과 확산의 성질을 모두 만족할 수 있음
        + DES는 여러 라운드에 걸쳐 치환과 순열을 반복하는 곱 암호의 일종
    - DES 외에도 많은 현대 블록 암호들은 곱 암호의 구조를 차용하고 있음

<br/>

* 페이스텔(Feistel) 구조
    - DES에서 라운드 함수를 적용하는 전체 과정은 페이스텔 구조를 이루고 있음
        + DES의 페이스텔 구조
          <br/><br/>
          <img width="2560" alt="fiestel" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/7d3f4703-5699-4285-ba03-38ab4cebfa31"><br/><br/>
            | 순서 | 설명 |
            |:---:|------|
            | 1 | 입력으로 들어온 블록을 동일한 길이의 왼쪽 블록 L과 오른쪽 블록 R으로 나눔 |
            | 2 | 각 라운드마다 오른쪽 블록은 다음 라운드의 왼쪽 블록으로 입력됨 (Red Line) |
            | 3 | 각 라운드마다 왼쪽 블록은 오른쪽 블록에 라운드 함수 F를 적용한 결과와 XOR되어 다음 라운드의 오른쪽 <br/>블록으로 입력됨 (Green Line) |
    - 페이스텔 암호의 특징
        | | 설명 |
        |---|------|
        | 장점 | 📌 블록 암호의 특징: 일반적으로 암호화를 구성하는 각 함수들에 역함수가 존재함 <br/> &nbsp;&nbsp; - 페이스텔 구조를 사용하면 라운드 함수 F가 복호화과정에서 XOR로 상쇄되므로 **역함수가 존재하지 않아도 됨** <br/> &nbsp;&nbsp; - 암호화와 복호화의 구조가 동일함(입력 순서가 반대) <br/> &nbsp;&nbsp;&nbsp;&nbsp; → **암호화에 사용한 라운드 키를 역순으로 입력**하면 복호화가 이뤄짐 |
        | 단점 | 비페이스텔 암호와 같은 안전성을 갖기 위해 두 배 정도 라운드를 사용해야 함 <br/> &nbsp;&nbsp; - 오른쪽 블록은 다음 라운드의 왼쪽 블록으로 어떠한 처리도 없이 입력되기 때문 |

<br/><br/>

## DES의 과정
| STEP | 설명 |
|:---:|-----|
| 1 | **초기 순열**(Initial Permutaiton, IP) <br/> : 초기 순열 테이블(IPT)를 이용하여 64비트 입력을 비트 단위로 전치함 |
| 2 | 총 16번의 라운드를 수행 → 페이스텔 구조 파트에서 설명한 1\~3번 과정을 수행함 <br/> &nbsp;&nbsp; - 1번은 라운드 시작 시 한 번만 수행하고, 2\~3번을 반복해서 수행함 |
| 3 | **최종 순열**(Final Permutation, FP) <br/> : 최종 순열 테이블(FPT)를 이용하여 64비트 입력을 비트 단위로 전치함 |

<br/>

### STEP 1 & 3: 초기 순열, 최종 순열
* 각각 초기 순열 테이블(Initial Permutation Table, IPT), 최종 순열 테이블(Final Permutation Table, FPT)을 이용하여 64비트의 입력을 비트 단위로 전치함
    - 테이블의 ```n```번째 값이 ```m```일 때, 출력의 ```n```번째 비트는 입력의 ```m```번째 값으로 대치됨
* 초기 순열과 최종 순열은 서로 **역관계**에 있음
    - 임의의 64비트 데이터에 초기 순열을 적용하고, 최종 순열을 적용하면 입력 값이 그대로 출력도;ㅁ
* 📌 DES의 안전성을 증가시키진 않지만, **DES를 하드웨어에 구현하기 쉽게 해줌**
    

<br/>

### STEP 2: 총 16번의 라운드 수행 (페이스텔 구조 적용)
* 각 라운드의 오른쪽 블록에 적용되는 라운드 함수 F
    | | 설명 |
    |:---:|------|
    | 입력 | 오른쪽 블록 R만 입력됨 → 입력의 길이 = 32비트 |
    | 구성 요소 | 확장 순열(Expansion P-Box), 라운드 키 결합(XOR), 치환 테이블(S-Box), 고정 순열(Straight P-Box) |
  <br/>
  <img width="2560" alt="DES 라운드 함수" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/936703db-8b2e-4081-9fc9-46d2622ea627"><br/><br/>


* 라운드 함수 F의 과정 1: **확장 순열**(Expansion P-Box)
    - 32비트 입력을 비트 단위로 전치하는 동시에, 전체 길이릴 **48비트**로 확장함
        + 32비트의 입력값을 4비트씩 8개의 부분을 나눔 → 테이블을 참조하여 각각을 6비트로 확장함
        + 테이블만 다를 뿐, 초기 순열/최종 순열과 동일한 방식으로 이루어짐

* 라운드 함수 F의 과정 2: **라운드 키 결합**(XOR)
    - 과정 1의 출력을 키 생성 함수로 생성된 48비트 라운드 키 ```K```와 XOR 연산을 수행함

* 라운드 함수 F의 과정 3: **치환 테이블**(S-Box)
    - 과정 2에서 출력된 48비트의 결과 값을 32비로 축소함
        + 4개의 행과 15개의 열로 이루어진 표를 사용하며, 표의 각 값은 4비트로 표현되는 수
    - S-Box가 적용되는 과정
        | 순서 | 설명 |
        |:---:|------|
        | 1 | 입력을 6비트씩 총 8개의 부분으로 나눔 |
        | 2 | 6비트 중 첫 번째와 마지막 비트로 행을 결정하고, 나머지 네 개의 비트로 열을 결정함 |
        | 3 | S-Box의 표에서 행과 열을 참조하여 값을 반환함 |
        + DES에서는 여섯 비트로 자른 부분마다 다른 S-Box를 사용함

* 라운드 함수 F의 과정 4: **고정 순열**(Straight P-Box)
    - 과정 3에서 출력된 32비트의 결과 값을 테이블을 이용하여 비트 단위로 전치함 (테이블만 다를 뿐 다른 순열과 방식은 동일함)

<br/>

### STEP 2+: 각 라운드에 사용되는 키 생성 함수(Key Scheduling)
* 64비트의 입력을 받아 각 라운드에 필요한 48비트 라운드 키를 생성하는 함수
  <br/><br/>
  <img width="2560" alt="DES 키 생성 함수" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/4b3467a2-d221-46e4-9e81-25f6eac4c310"><br/><br/>
* 구성 요소
    - **패리티 비트 제거**(Parity Bit Drop): 입력에서 패리티 비트(8비트)를 제거하고, 남은 56비트에 순열을 적용하는 과정
        + DES의 비밀키에서 각 바이트의 가장 오른쪽 비트 = 자신이 속한 바이트의 나머지 7비트에 대한 **홀수 패리티 비트**(Odd Parity Bit)
        + 📄 **패리티 비트**(Parity Bit)
            - 1의 개수가 홀수가 되도록 할지, 아니면 짝수가 되도록 할지에 따라 홀수 패리티 비트와 짝수 패리티 비트로 구분됨
                | 종류 | 설명 |
                |:---:|------|
                | 홀수 패리티 비트 <br/> (Odd Parity Bit) | 한 바이트를 이진수로 표현했을 때 1의 개수가 홀수가 되도록 덧붙인 비트 <br/> &nbsp;&nbsp; - EX: ```1010101```의 경우 1이 4개 존재하므로 홀수 패리티 비트 적용 시 <br/> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;끝에 ```1```이 추가되어 ```10101011```이 전송됨 |
                | 짝수 패리티 비트 <br/> (Even Parity Bit) | 한 바이트를 이진수로 표현했을 때 1의 개수가 짝수가 되도록 덧붙인 비트 <br/> &nbsp;&nbsp; - EX: ```1010101```의 경우 1이 4개 존재하므로 짝수 패리티 비트 적용 시 <br/> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;끝에 ```0```이 추가되어 ```10101010```이 전송됨 |
            - 패리티 비트는 **통신 중에 비트 반전이 일어나지 않았음을 보증하는 역할**을 함
                | 종류 | 설명 |
                |:---:|------|
                | 홀수 패리티 비트 | 수신한 바이트 중 1의 갯수가 짝수인 바이트가 존재함 → 그 바이트에서 임의의 비트에 반전이 일어났음을 알 수 있음 |
                | 짝수 패리티 비트 | 수신한 바이트 중 1의 갯수가 홀수인 바이트가 존재함 → 그 바이트에서 임의의 비트에 반전이 일어났음을 알 수 있음 |
                + 임의의 비트에 반전이 발생했음을 확인한 수신자는 손상되지 않은 데이터를 얻기 위해 재전송을 요구할 수 있음

    - **쉬프트**(Shift): 입력을 왼쪽 28비트와 오른쪽 28비트로 나누어 각각을 1비트 또는 2비트만큼 왼쪽으로 순환 쉬프트(Cyclic Shift)하는 과정
        | 라운드 | 설명 |
        |:---:|------|
        | 1, 2, 9, 16 라운드 | 1비트만큼 왼쪽으로 순환 쉬프트(Cyclic Shift)함 <br/> &nbsp;&nbsp; - EX: ```10101111```을 왼쪽으로 1비트 순환 쉬프트하면 왼쪽 끝의 ```1```이 오른쪽 끝으로 이동하여 ```01011111```이 됨 |
        | 그 외 라운드 | 2비트만큼 왼쪽으로 순환 쉬프트(Cyclic Shift)함 <br/> &nbsp;&nbsp; - EX: ```10101111```을 왼쪽으로 2비트 순환 쉬프트하면 왼쪽 끝의 ```10```이 오른쪽 끝으로 이동하여 ```10111110```이 됨 |

    - **압축 순열**(Compression P-Box): 56비트의 입력을 48비트 길이로 압축하는 과정
        + 56비트의 입력값을 테이블을 이용하여 비트 단위로 전치함 (테이블만 다를 뿐 다른 순열과 방식은 동일함)

<br/><br/>

## DES 응용

### 다중 DES
* 서로 다른 키를 사용하는 DES 모듈을 여러 개 이어붙여서 DES의 약점을 보완한 암호 시스템
    - 연산 능력이 증대되고 관련된 공격 기법이 연구됨에 따라 DES룰 더 이상 안전한 암호 시스템으로 사용할 수 없게 되면서 등장하게 됨
* 다중 DES의 종류
    | 종류 | 설명 |
    |:---:|------|
    | 이중 DES <br/> (Double DES, 2-DES) | 112비트의 키를 사용하며, DES를 두 겹으로 사용함 <br/> &nbsp;&nbsp; - 단일 DES와 비슷한 안전성을 가지고 있음 |
    | 삼중 DES <br/> (Triple DES, 3-DES) | 168비트의 키를 사용하며, DES를 세 겹으로 사용함 <br/> &nbsp;&nbsp; - 키 길이를 2배 늘리는 효과밖에 얻지 못함 (단일 DES보다는 높은 안전성을 가진다고 알려져 있음) |
    - 둘 모두 48비트의 키를 사용하는 DES보다 늘어난 키를 사용하기 때문에 안전할 것처럼 보이지만, **중간 일치 공격**으로 인해 안전성을 획기적으로 높이지는 못함

<br/>

### 다중 DES의 중간 일치 공격(Meet-in-the-Middle Attack)
* 중간 일치 공격(Meet-in-the-Middle Attack): 공격자가 어떤 평문 ```p```와 ```p```를 암호화한 암호문 ```c```를 알 수 있을 때 수행할 수 있는 공격
* 이중 DES에 대한 중간 일치 공격
    - 공격자가 어떤 평문 ```p```와 ```p```를 암호화한 암호문 ```c```를 알 수 있을 때 이중 DES의 안전성은 DES의 두 배 정도 <br/> &nbsp;&nbsp; → 이중 DES에 기대되는, 112비트 키를 사용하는 DES의 안전성에 비해 한참 부족함
* 삼중 DES에 대한 중간 일치 공격
    - 중간 일치 공격에 대해 112비트 키를 사용하는 DES 이상의 안전성을 가진다고 알려져 있음 <br/> &nbsp;&nbsp; → 📌 **다중 DES를 사용할 때에는 일반적으로 삼중 DES를 사용함**


<br/><br/><br/><br/>
### 🔖 출처
* [드림핵 Cryptography] 📌 [블록암호: DES](https://dreamhack.io/lecture/courses/72)
