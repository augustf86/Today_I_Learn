# 블록 암호: 운영 모드

* DES와 AES 등의 블록 암호는 한 번에 한 블록의 평문을 암호화하기 위해 설계되었음
    - UTF-8로 인코딩할 때 알파벳 한 글자는 8비트에 대응됨 → DES와 AES에서 암호화할 수 있는 글자들의 수
        | 암호 | 한 블록의 크기 | 한 번에 처리할 수 있는 알파벳의 수 |
        |---|------|------|
        | DES | 64비트의 평문 | 8글자를 한 번에 암호화할 수 있음 |
        | AES | 128비트의 평문 | 16글자를 한 번에 암호화할 수 있음 |
    - 일반적으로 사용되는 평문의 길이는 블록 암호가 한 번에 처리할 수 있는 길이를 넘는 경우가 많음 → *운영 모드를 도입함*

<br/>

* **운영 모드**(Mode of Operation): 블록 암호로 다양한 크기의 데이터를 처리할 수 있도록 고안된 블록 암호의 사용 방법
    - 여러 종류가 존재함 → 블록 암호를 사용하는 서비스는 각각의 장단점을 고려하여 운영 모드를 선택함

<br/><br/>

## 패딩(Padding)
* 평문에 데이터를 붙여서 평문의 크기가 블록 크기의 배수가 되도록 만드는 과정
    - 패딩이 필요한 이유
        + 블록 암호는 블록 단위로 암호화를 수행함 → 입력의 길이가 정확하게 블록 크기의 배수가 되어야 함
        + 📌 일반적으로 평문의 크기는 블록 크기의 배수가 되지 않음
    - 패딩된 암호문을 복호화할 때 주의할 점
        + ⚠️ **복호화된 평문에서 패딩을 제거해야 원래의 평문을 얻을 수 있음** <br/> &nbsp;&nbsp;&nbsp;&nbsp; → 패딩된 암호문의 수신자는 **어떤 패딩이 적용되었는지** 알아야 암호문을 제대로 복호화할 수 있음

<br/>

### 널리 사용되는 패딩 기법
* 비트 패딩(Bit Padding): 마지막 블록에서 평문이 채우지 못하는 비트 중 최상위 비트를 1로 설정하고, 나머지는 모두 0으로 채우는 패딩 기법
    - 암호문의 수신자는 평문의 마지막 비트부터 처음으로 값이 1인 비트가 나올 때까지를 패딩으로 인식함 → 이를 제거하여 평문을 복구할 수 있음
    - 비트 패딩의 문제점과 그 해결책
        | | 설명 |
        |---|------|
        | 문제점 | **블록의 크기가 정확히 블록의 배수일 때**, 수신자가 메시지의 일부를 패딩으로 오인하게 되는 문제가 존재함 |
        | 해결책 | 비트 패딩을 적용할 때는 평문의 크기가 블록의 배수이면 패딩으로 한 블록을 추가함 |
        +  비트 패딩의 예시: 평문 = ```|1011 1011 1111 1000|``` 
            | | 설명 |
            |:---:|------|
            | 문제 상황 | 수신자는 뒤의 네 비트(```1000```)를 패딩으로 인식하고 제거함
            | 해결책 적용 | 송신자는 패딩으로 ```\|1000 0000 0000 0000\|```를 추가해야 함 <br/> &nbsp;&nbsp; - 수신자에게 ```\|1011 1011 1111 1000\|1000 0000 0000 0000\|```이 전달됨 <br/> &nbsp;&nbsp;&nbsp;&nbsp; → 마지막 한 블록을 평문으로 인식하여 제거하고, 평문을 오류 없이 복호화할 수 있음 |


* 바이트 패딩(Byte Padding): 바이트 단위로 패딩을 수행하는 패딩 기법
    - 바이트 패딩에는 여러 종류가 있음
        | 종류 | 설명 |
        |---|------|
        | ANSI X.923 | 마지막 블록의 남는 바이트를 임의의 값(일반적으로 0)으로 채우고, 마지막 바이트에 패딩의 길이를 기록하는 기법 <br/> &nbsp;&nbsp; - 예시: ```\|A3 B2 91 81 50 23 00 00\|14 50 00 00 00 00 00 04\|``` <br/> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; → 마지막 바이트의 값이 4이므로 네 바이트(```00 00 00 04```)가 패딩이 됨 <br/> &nbsp;&nbsp; - 평문의 크기가 블록 크기의 배수일 때 수신자가 평문을 패딩으로 오인할 수 있는 문제점이 있음 <br/> &nbsp;&nbsp;&nbsp;&nbsp; → 평문의 크기가 블록 크기의 배수일 때는 마지막에 한 블록을 패딩으로 추가함 |
        | PKCS#7 | AES와 같은 블록 암호의 패딩 기법을 제시하고 있는 PKCS(Public-Key Cryptography Standard)의 7번째 문서 <br/> &nbsp;&nbsp; - 추가할 패딩의 바이트 크기로 마지막 블록을 채우는 패딩 기법을 소개함 <br/> &nbsp;&nbsp; - 예시: ```\|A3 B2 91 81 50 23 00 00\|14 50 00 00 04 04 04 04\|``` <br/> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; → PKCS#7로 마지막 블록에 4바이트(```04 04 04 04```)를 패딩한 것 <br/> &nbsp;&nbsp; - 평문의 크기가 블록 크기의 배수이면 ```\|08 08 08 08 08 08 08 08\|```를 패딩으로 추가함 |

<br/><br/>

## 운영 모드
* 블록 암호로 평문을 암호화할 때의 과정
    | 순서 | 설명 |
    |:---:|------|
    | 01 | 평문은 패딩을 거친 뒤 여러 블록으로 나뉨 |
    | 02 | 각각의 블록은 블록 암호의 운영 모드에 따라 암호화됨 |

<br/>

### ECB(Electronic Code Book) 모드
<img width="2560" alt="ECB 모드" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/d23fb013-86cd-4d4d-a2e2-fe62ce429450">
<br/>

* 블록들이 모두 같은 키로 암호화되는, 가장 간단한 운영 모드
    - ECB 모드의 특징
        | | 설명 |
        |:---:|------|
        | 장점 | 각 블록이 독립적으로 암호화됨 → 여러 블록을 **병렬적으로** 암호화할 수 있음 |
        | 단점 | 다른 운영모드에 비해 **암호학적 안전성이 부족함** |

* ⚠️ ECB 모드의 취약점: **같은 블록은 같은 암호문으로 암호화됨**
    - 공격자는 암호문에서 평문의 정보를 습득하거나, 리플레이 공격(replay attack)을 수행하는 것이 가능해짐
    - ECB 모드의 취약점을 이용한 공격들
        |  | 설명 |
        |---|------|
        | 약한 혼돈 성질 | 이미지의 한 픽셀을 한 블록으로 하여 ECB 암호화하면 같은 픽셀들은 모두 같은 픽셀로 암호화됨 <br/> &nbsp;&nbsp; → 원본 이미지의 패턴이 암호화된 이미지에도 그대로 나타남 <br/> &nbsp;&nbsp;&nbsp;&nbsp; = ⚠️ 암호문으로부터 평문의 정보를 유추하기 어려워야 한다는 **혼돈 성질이 약함**을 의미 |
        | 재전송 공격 <br/> (replay attack) | 어떤 데이터를 재전송하여 시스템이 의도치 않은 행동을 하게 하는 것 |
      <img width="2560" alt="ECB 모드의 재전송 공격" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/31cf83c8-4783-4171-9f99-4413e860b0f0">


<br/>

### CBC(Cipher Block Chaining) 모드
<img width="2560" alt="CBC 모드" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/022a48cf-7b65-4978-adba-832042a5c5fd">
<br/>

* 어떤 블록을 암호화하기 전에, 이 블록을 직전 블록의 암호문과 XOR하는 운영 모드
    - 평문의 첫 번째 블록은 이전 블록이 존재하지 않음 → **초기 벡터**(IV)라고 불리는 임의의 데이터와 XOR함
        + 초기 벡터(Initialization Vector, IV)는 일반적으로 **논스**(Nonce, number used only once)라는 무작위 값을 사용함
            - 공격자가 알아도 안전성에 영향을 끼치지 않음
            - 공격자가 암호문을 중간에 가로채서 이를 조작할 수 있다면 복호화 결과의 첫 번째 블록을 조작할 수 있음 (CBC Bit-Flipping Attack) → ⚠️ **CBC 모드 사용 시 초기 벡터의 무결성을 보장해야 함**
    - 각 블록이 서로의 암호화에 영향을 줌 → 같은 블록도 전체 평문 및 IV에 따라 암호화 결과가 달라짐
    - CBC 모드의 장단점
        | | 설명 |
        |:---:|------|
        | 장점 | 재전송 공격에 강인하며, 높은 혼돈성을 가지고 있음 → 블록 암호의 운영 모드로 널리 사용되고 있음 |
        | 단점 | 한 블록을 암호화할 때 직전 블록의 암호화 결과를 사용하므로 여러 블록을 병렬적으로 처리할 수 있음 <br/> (복호화의 경우 모든 암호문 블록을 알고 있으므로 병렬적으로 처리할 수 있음)

* CBC Bit-Flipping Attack: 공격자가 초기 벡터를 원하는 값으로 조작하여 복호화된 평문의 첫 번째 블록을 조작하는 공격
  <br/><br/>
  <img width="2560" alt="CBC Bit-Flipping Attack" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/565a7cd5-623c-4095-bbd9-ed5bb3742ce8">


<br/>


<br/><br/><br/><br/>
### 🔖 출처
* [드림핵 Cryptography] 📌 [블록암호: 운영모드](https://dreamhack.io/lecture/courses/73)
