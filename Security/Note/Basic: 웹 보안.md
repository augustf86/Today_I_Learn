# Basic: 웹 보안

## 사용자 인증
* 웹 애플리케이션에서 사용하는 가장 기본적인 보안 기능 → **정보에 접근할 수 있는 사용자가 유효한지 인증하는 것**
    |  | 설명 |
    |---|------|
    | 과거 | - 사용자를 인증할 때 패스워드 방식을 주로 사용함 <br/> - 인터넷 뱅킹이 발달된 이후로는 공인인증서(현 공동인증서) 방식도 많이 사용함 |
    | 현대 | - 스마트폰의 보급으로 좀 더 강화된 사용자 인증 방식인 생체 인증도 점차 늘고 있는 추세임 |

<br/>

### 방법 1: 패스워드
* 패스워드 = **"가장 널리 사용되는 기본적인 사용자 인증 방식"**
    - 쉬운 패스워드를 사용하면 누구나 쉽게 패스워드를 추측할 수 있음 → 최근에는 쉬운 패스워드 사용 시 회원가입 자체나 비밀번호 변경이 불가능하도록 조치를 취하고 있음

<br/>

* 안전한 패스워드를 만드는 기준
    | 속성 | 설명 | 예시 |
    |---|------|------|
    | 길이 | 세 종류 이상의 문자 구성 + 8자리 이상 | pwd1234!@ <br/>(영문 소문자, 숫자, 특수문자로 구성 + 총 9자리) |
    | | 두 종류 이상의 문자 구성 + 10자리 이상 | passwd1234 <br/>(영문 소문자, 숫자로 구성 + 총 10자리) |
    | 형태 | 특정 명칭을 예측이 어렵도록 가공 | '인터넷해킹과보안'의 홀수번째 문자들만 추출해 <br/>'인넷킹보'를 영문으로 입력한 dlssptzldqh |
    | | 노래 제목이나 명언, 속담, 가훈 등을 가공 | '백설공주와 일곱 난쟁이'를 '백설+7난장'으로 줄인 후 <br/>이를 영문으로 입력한 qortjf+7skswkd |
    | | 패스워드 길이를 늘리기 위해 알파벳 문자 중간에 특수 문자/숫자 삽입 | passwd1234를 pa!@ss1234wd로 가공 |
    | | 기본 패스워드 문자열을 설정한 뒤 사이트별 특정 규칙을 적용 | WCRB를 기본 문자열로 설정하고 <br/>사이트 이름을 앞뒤에 추가한 na+WCRB+aver |

<br/>

* 안전하게 패스워드를 관리하는 방법
    - 안전한 패스워드를 만드는 것만큼 안전하게 관리하는 것도 중요함
        + 패스워드를 복잡하게 만들어도 기억하지 못하거나 메모지에 적어 타인에게 노출되기 쉬운 곳에 붙여놓으면 무용지물이 됨
        + 가장 좋은 방법은 사람의 기억이지만, 기억력에는 한계가 있어 외부 기억장치를 빌려서 저장해놓는 것이 효과적임
            - 여전히 외부 노출 가능성이 남아있으므로 타인이 쉽게 알아볼 수 없는 자기만의 고유한 방법으로 보관하는 것을 권장함
    - 패스워드 관리 방법 
        + 방법 1: 패스워드 변형
            - 가장 기초적인 문자 치환형 변환 방식인 ROT13 방식(*13글자씩 밀어서 암호로 만드는 방식*)을 이용한 패스워드 변형 실습
              <img width="2560" alt="패스워드 변형" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/d47e27d6-ff40-46d8-8ff5-e94a25efeca9">
            - 혹시 노출되더라도 인코딩/디코딩에 대해 모르는 일반인의 경우 유출된 계정을 쉽게 도용할 수 없음
        + 방법 2: 패스워드 보관 파일의 암호화
            - 패스워드 보관을 위해 엑셀 파일을 사용할 경우 해당 엑셀 파일의 시트 이름 부분을 마우스 오른쪽 버튼을 클릭하고 [숨기기(H)] 메뉴를 클릭하여 해당 시트가 보이지 않게 만들 수 있음
                + 패스워드가 의도치 않게 타인에게 노출될 가능성을 줄이는 효과가 있음
            - 패스워드 파일 자체에 본인만 알 수 있는 패스워드를 걸어두는 것이 보다 안전함
                + 패스워드 파일 비밀번호 하나만 기억하면 되기 때문에 사용자가 잊어버릴 확률이 적음
                + 패스워드 파일 자체를 암호화하여 해당 파일이 유출되더라도 파일 내용을 알 수 없음
        + 방법 3: 외부 저장장치와 컴퓨터 하드디스크에 이중 보안
            - 컴퓨터에 저장된 정보는 악의적인 해커에 의해 유출되거나 컴퓨터가 심각한 손상을 입을 경우 복구할 수 없음 → USB와 같은 **외부 저장장치에 저장해두는 것**을 권장함
            - 패스워드 파일을 안전하게 보관해놓으면 팡리이 유출되더라도 패스워드까지 노출되는 위험을 줄일 수 있음

<br/>

### 방법 2: 공인인증서 (현 공동인증서)
* 공인인증서(현 공동인증서): 전자 서명의 검증에 필요한 공개키에 소유자 정보를 추가하여 만든 일종의 전자 신분증(증명서)
    - 패스워드 인증 메커니즘보다 **한 단계 강화된 사용자 인증 방식**
    - 공개키와 비밀키의 쌍을 이용하여 사용자를 인증하는 **공개키 기반 구조(Public Key Infrastructure) 메커니즘**을 사용함
        | 키 종류 | 설명 |
        |---|------|
        | 공개키 | 외부에 공개되어 있으며, 모든 사람이 공개키로 암호화할 수 있음 (복호화 불가) |
        | 비밀키 | 소유자 자신만 가지고 있으며, 공개키로 암호화한 내용은 쌍을 이루는 비밀키로만 복호화할 수 있음 |
    - 공인인증서(현 공동인증서)에 들어가는 정보는 **ITU-T의 X.509 표준**에 기술되어 있음
        + 공인인증서(현 공동인증서)에 포함된 속성 정보
            | 속성 | 설명 |
            |---|------|
            | 일련 번호 | 증명서를 개별 인증할 때 사용함 |
            | 주체 | 사람의 이름 또는 증명자 |
            | 서명 알고리즘 | 서명을 만드는 데 사용하는 알고리즘 |
            | 발행자 | 정보를 검증하고 증명서를 발행하는 주체 |
            | 유효 기간 | 시작 일자: 처음 효력이 발생한 날짜 <br/> 만료 일자: 효력 만기일 |
            | 키 이용 목적 | 공인키 사용 목적 (EX: 인증 서명) |
            | 공인키 | SSL 목적 |
            | 지문 알고리즘 | 인증서를 해시하는 데 사용한 알고리즘 |
            | 지문 | 증명서가 개봉되지 않았음을 증명하는 해시 자체 |
    - 공인인증서(현 공동인증서) 발급 방법과 저장 위치
        | | 설명 |
        |----|------|
        | 발급 | 가까운 은행에서 발급 신청을 한 후 해당 은행 사이트의 공인인증센터에서 발급받을 수 있음 |
        | 저장 위치 | 발급받은 공인인증서 파일은 기본적으로 ```C:\Users\사용자계정\AppData\LocalLow\NKPI```에 저장됨 <br/> (외부 저장장치나 스마트폰 등에 저장할 수 있음) <br/> &nbsp;&nbsp; - 공인인증서 발급 기관에 따라 개별적으로 폴더가 생성됨 <br/> &nbsp;&nbsp;&nbsp;&nbsp; → 폴더에서 공인인증서 파일을 더블클릭하면 일반적인 내용을 볼 수 있음 <br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([자세히] 탭 클릭 시 내용 및 구조를 살펴볼 수 있음) |

<br/>

### 방법 3: 생체 인증
* 생체 인증 방식: 인증을 받고자 하는 사람의 '그 자체'를 인증 수단으로 이용하는 것
    - 일반적으로 웹에서 사용자를 인증하는 데 사용되지는 않음
    - 사용자를 인증하는 현존 방식 중 **가장 강화된 것**
        + 스마트폰의 사용이 증가하면서 지문, 얼굴 인식 등 생체 인식 방법이 많이 사용되고 있음
        + 일부 강화된 보안이 필요한 경우에는 홍채 인식이나 DNA 등이 사용되는 경우도 있음

<br/>

* 생체인증의 종류
    | 생체 인증 | 설명 |
    |---|------|
    | 지문 | 지문을 구성하는 융선과 골의 패턴이 개인별로 다르다는 점에서 착안되어 패턴의 고유성 및 차이를 이용하여 개개인을 식별하는 방법 <br/> &nbsp;&nbsp; - 지문: 개인의 고유한 생체 정보로 **일생 동안 변하지 않는다**는 특징이 있음 <br/> &nbsp;&nbsp;&nbsp;&nbsp; - 표피면에서 위로 돌출한 융선과 그 사이의 공간인 골로 구성되어 있음 <br/> &nbsp;&nbsp; - 🔖 지문 인식의 두 가지 과정: **지문 등록**(Enrollment) → **지문 인증**(Vertification) <br/> &nbsp;&nbsp;&nbsp;&nbsp; 1. 지문 등록: 지문 센서로부터 입력받은 고유한 특징을 추출하여 데이터베이스에 저장하는 과정 <br/> &nbsp;&nbsp;&nbsp;&nbsp; 2. 지문 인증: 재입력된 지문으로부터 특징을 추출한 후 입력된 데이터베이스의 내용과 비교하여 사용자를 인증하는 것 |
    | 손 모양 | 손을 폈을 때 손가락의 길이와 굵기 등의 요소를 인증에 사용하는 방법 <br/> &nbsp;&nbsp; - 비교적 간편하고 인증 데이터의 크기도 작은 편 → 빠르게 인증을 수행할 수 있음 <br/> &nbsp;&nbsp; - 📌 **사람의 손 모양 다양성이 높은 인증 수준이 될 만큼 완벽하게 크지는 않음** (비슷한 사람도 많고 쉽게 조작할 수 있음) <br/> &nbsp;&nbsp; - 손의 표피 가까이에 있는 정맥 모양을 촬용하여 인증하는 방식도 존재함 <br/> &nbsp;&nbsp;&nbsp;&nbsp; → 손 모양을 사용하는 것보다는 보안 수준이 높지만 장비가 크고 비싸다는 단점이 있음 |
    | 망막 | 눈 뒷부분에 있는 모세햘관의 형태(굵기와 흐름)를 확인하여 인증을 수행하는 방법 <br/> &nbsp;&nbsp; - 정확도가 매우 높은 편이지만 검사하는 데 시간이 10~15초 정도로 긴 편임 <br/> &nbsp;&nbsp; - 심장이 멎어 피의 흐름이 멈추면 인증이 불가능하고 눈병 등 외부적인 요인에 따른 인식률의 격차가 큼 <br/> &nbsp;&nbsp; - 📌 **정확도가 매우 높은 편이지만, 이용자의 거부감을 불러일으킬 수 있음** → 매우 높은 수준의 인증이 필요한 경우에 제한적으로 사용 |
    | 홍채 | 사람마다 다른 홍채(*눈동자의 색을 결정하는 부분*)의 패턴을 수학과 통계학 알고리즘으로 구분하여 개개인을 식별하는 방식 <br/> &nbsp;&nbsp; - 📌 **홍채를 인증한 인증 방식은 망막을 이용한 것보다 정확도가 높음** <br/> &nbsp;&nbsp; - 50cm 정도에서도 인증이 가능해 가까이에서 오래 장비에 눈을 맞춰야 하는 망막 인식 기술보다 훨씬 거부감이 낮음 |
    | 서명 | 한국보다는 외국에서 서명을 사용하는 경우가 많은 편이라 서명을 이용한 인증장치도 존재함 <br/> &nbsp;&nbsp; - 장비를 이용하여 서명의 진위를 확인하는 방식 → 📌 **보안 수준이 낮은 편** |
    | 목소리 | 사람마다 목소리가 다르다는 점을 이용한 생체인증 방법 <br/> &nbsp;&nbsp; - 장소에 구애받지 않고 사용할 수 있고 교육이나 학습도 필요가 없어 편리하며, 사용 가격도 저렴함 <br/> &nbsp;&nbsp; - 목소리는 환경이나 갖멍에 따라 변할 수도 있고 사람이 쉽게 모방할 수 있음 → 📌 **보안 수준이 낮은 편** |
    | 얼굴 | 얼굴 인증(Facial Scan) 장비를 이용해 사람의 얼굴로 특정인을 인증함 <br/> &nbsp;&nbsp; - 다양한 표정의 얼굴을 정확히 인증하는 것에 한계가 있어 무표정한 얼굴로 진행해야 함 <br/> &nbsp;&nbsp; - 애플의 FaceID가 대표적임 |
    | 뇌파 | 뇌파(EEG)를 인식하는 헤드샛(뇌파 센서)을 이용하여 패스워드를 입력하는 방법이 개발됨 (생각하는 것만으로도 비밀번호를 입력할 수 있음) <br/> &nbsp;&nbsp; - 의료용으로 사용하는 EEG 센서를 사용하지 않고 생각 인식(Passthought)을 통한 본인 인증을 하는 방법을 연구함 <br/> &nbsp;&nbsp; - 모의 실험 결과 인증 방식의 오류율은 1% 남짓 <br/> &nbsp;&nbsp; - 아직까지는 상용화되지 않고 연구 단계에 머물러 있음 (미래의 보안 수단 중 하나) |

<br/>

* 생체 인증의 성능 측정
    - 생체 인증의 성능 측정 기준: *'얼마나 정확하게 그 사람의 신분을 탐지할 수 있는가*
        | 측정 기준 | 설명 |
        |---|------|
        | FRR(False Rejection Rate) <br/> = Type 1 Error | 권한이 있는 사람이 인증을 시도했을 때 실패하는 비율 = 본인의 정보를 타인의 것으로 판단할 확률(오거부율, 본인거부율) <br/> &nbsp;&nbsp; - 인증 시스템이 지나치게 높은 정확도를 요구하거나, 탐지하는 생체 특성이 건강/환경 등 외부 요인에 의해 쉽게 변할 수 있는 경우 FRR이 높아짐 <br/> &nbsp;&nbsp; - 정확도가 높아짐에 따라 오류율이 올라감 |
        | FAR(False Acceptance Rate) <br/> = Type 2 Error | 권한이 없는 사람이 인증을 시도했을 때 성공하는 비율 = 타인의 정보를 본인의 것으로 판단한 확룰(오인식률, 타인수락율) <br/> &nbsp;&nbsp; - ⚠️ **FRR이 높은 것보다 FAR이 높은 것이 더 심각한 문제가 됨** <br/> &nbsp;&nbsp;&nbsp;&nbsp; (FRR이 높으면 실패한 인증을 재시도하면 되지만, FAR이 높으면 침입을 허용하기 때문) <br/> &nbsp;&nbsp; - 정확도가 높아짐에 따라 오류율이 내려감 |
        | EER(Equal Error Rate) <br/> = CER(Crossover Error Rate) | FRR과 FAR이 그리는 곡선의 교차점 = FAR과 FRR이 같아지는 지점 (동일오류율) <br/> &nbsp;&nbsp; - 일반적으로 생체 인증 장비의 정확도를 설정할 때엔 EER에 맞춤 <br/> &nbsp;&nbsp; - 좋은 생체 인증 방식은 FAR과 FRR이 만나는 지점인 EER이 낮은 것임 |
      <img width="2560" alt="ERR" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/9f32f495-621c-429c-8614-7155d7f8418f">


<br/><br/>

## 접근 통제
* 접근 통제의 단계
    1. 보호하려는 정보의 가치를 결정함
        + 보호할 정보의 가치를 모르면 그에 따른 적절한 대책을 세우기 어려움
    2. 결정된 정보의 가치를 바탕으로 거기에 맞는 적절한 보안 수준을 부여함
        + 정보의 가치와 기준은 정보를 가지고 있는 개인 또는 조직의 특성에 따라 얼마든지 바뀔 수 있음 → 보안 수준도 매우 다양하게 나타날 수 있음
            - 예시: 정부(군대)에서 일반적으로 사용하는 보안 수준
                | 보안 등급 | 설명 |
                |---|------|
                | Top Secret(TS) | 공개되었을 때 국가 보안에 '극도의 치명적인 피해'를 입힐 수 있는 정보 → 국가 수준에서 가장 높은 보안 등급 (우리나라의 '1급 비밀') |
                | Secret | 공개되었을 때 국가 보안에 '심각한 피해'를 입힐 수 잇는 정보 (우리나라의 '2급 비밀') |
                | Confidential | 공개되었을 때 국가 보안에 '피해'를 입할 수 있는 정보 (우리나라의 '3급 비밀') |
                | Restricted | 공개되었을 때 '의도치 않은 영향'을 미칠 수 잇는 정보 (우리나라의 '대외비') <br/> &nbsp;&nbsp; - 일부 국가에서는 이 등급이 없는 경우도 있음 |
                | Unclassified | 분류되지 않은 정보 중에서 민감하지 않은 정보이지만, 공개되어도 아무 문제가 없다는 의미는 아님 |

<br/>

### 접근 통제 모델
보안 수준에 따라 나뉜 정보는 각각 그 수준에 맞는 접근 통제를 수행해야 함 → 특정 구조와 그 구조를 담아낼 수 있는 틀이 필요함

<br/>

* DAC(Discretionary Access Control) = 임의적 접근 통제
    - 정보 소유자가 정보의 보안 수준을 결정하고, 그에 따른 접근 통제까지 결정하는 모델
        + 대표적인 예: 유닉스/윈도우에서 수행하는 파일에 대한 접근 통제 설정
    - DAC의 단점
        + 파일 소유자(정보 소유자)가 보안 수준과 접근 통제를 설정함 → **중앙 집중화된 정보 관리가 어려움** (사실상 정보에 대한 엄격한 접근 통제는 불가능함)

<br/>

* MAC(Mandatory Access Control) = 강제적 접근 통제
    - 미리 정해진 정책과 보안 등급을 바탕으로 이용자에게 부여된 권한과 정보에게 부여된 허용 등급을 비교하여 접근을 통제하는 모델
    - 중앙 집중화된 정보 관리를 위한 MAC 모델의 종류
        + Bell-Lapadula 모델
            | | 설명 |
            |---|------|
            | 사용 목적 | **정보의 기밀성**에 따라 상하 관계가 구별된 정보를 보호하기 위해 사용함 <br/> &nbsp;&nbsp; ⇒ 📌 **정보의 기밀성에 따른 차단에 주목적이 있음** |
            | 문서에 대한 <br/>읽기 권한 | - 상위 문서 읽기 금지(No read up): 낮은 수준의 보안 권한을 가진 사람이 높은 보안 수준의 문서를 읽을 수 없음 <br/> - 하위 문서 읽기 허용(Read down): 자신의 권한보다 낮은 수준의 문서는 읽을 수 있음 |
            | 문서에 대한 <br/>쓰기 권한 | - 상위 문서 쓰기 허용(Write up): 자신의 권한보다 높은 보안 수준의 문서에는 쓰기가 가능함 <br/> - 하위 문서 쓰기 금지(No write down): 자신의 권한보다 낮은 보안 수준의 문서에는 쓰기 권한이 없음 <br/> &nbsp;&nbsp; → 📌 *property(start property) |
          <img width="2560" alt="Bell-LaPadula" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/3b105d25-ccab-4fb4-9c5e-d7b0dec5308d">
              
        + Biba 모델
            | | 설명 |
            |---|------|
            | 사용 목적 | 기밀성보다 좀 더 신뢰할 수 있는 정보, 즉 **정보의 무결성**을 높이는 것이 목적인 경우에 사용함 <br/> &nbsp;&nbsp; ⇒ 📌 **정보 전체의 신뢰도 향상에 주목적이 있음** |
            | 문서에 대한 <br/>읽기 권한 | - 상위 문서 읽기 허용(Read Up): 자신의 무결성 수준보다 높은 무결성 수준의 문서를 읽을 수 있음 <br/> - 하위 문서 읽기 금지(No read down): 자신의 무결성 수준보다 낮은 무결성 수준의 문서는 읽을 수 없음 |
            | 문서에 대한 <br/>쓰기 권한 | - 상위 문서 쓰기 금지(No write up): 낮은 무결성 수준의 정보를 더 높은 무결성 수준의 문서에 쓸 수 없음 <br/> - 하위 문서 쓰기 허용(Write down): 높은 무결성 수준의 정보를 더 낮은 무결성 수준의 문서에 쓸 수 있음 |
          <img width="2560" alt="Biba" src="https://github.com/augustf86/Today_I_Learn/assets/122844932/49e32f60-a8dc-4e85-99c1-9fd6eb52fecf">
        + 그 외에도 Chinese-Wall 모델, Harrison Ruzo-Ulman 모델, Clark & Wilson 모델 등이 있음

<br/>

* RBAC(Role-Based Access Control) = 역할 기반 접근 통제
    - 사람이 아닌 직책(역할)에 따라 권한을 부여하는 것
        + 직책에 따른 권한을 각각 설정해 두고 직책만 변경하여 손쉽게 권한을 변경할 수 있음 → 다수의 사람에 대해 유연하고 직관적이며 효율적인 통제를 가능하게 함
    - RBAC의 필요성: 📌 **Authorization Creep**
        - 권한이 변경될 때 전에 가지고 있는 권한을 모두 지우거나 변경하는 것이 당연하지만, **일반적으로 기존 권한은 그대로 두고 새로운 업무 수행에 필요한 권한을 추가로 부여받는 경우가 많음**
        - 직책을 여러 번 옮기게 되면 불필요한 권한을 많이 가지게 됨 → 해당 직원의 권한이 확대되는 결과를 가져옴

<br/>

### 접근 통제 구현 방법
* 관리적 접근 통제
    - 관리적 접근 통책은 보안 정책을 구성하고 절차와 지침을 개발하는 것이 포함됨
        + 정책과 지침 내에 어떤 통제가 사용되어야 하는지를 결정해야 함
    - 크게 두 가지로 구분할 수 있음
        | 구분 | 설명 |
        |---|------|
        | 1 | 정책 및 절차를 수립하여 조직에서 보유하고 있는 중요 정보가 무엇인지 식별하고 그에 따른 통제 방안을 수립하는 것 |
        | 2 | 내부 임직원들이 회사의 보안 정책을 준수하도록 하기 위한 직원 통제 활동 <br/> &nbsp;&nbsp; - 직무 분리, 직무 교대, 감독 구조, 보안 인식 훈련 등이 있음 |

<br/>

* 논리적 접근 통제 (= 기술적 통제)
    - 보호해야 할 정보에 접근하는 것을 제한하기 위해 사용하는 하드웨어와 소프트웨어 도구
    - 논리적 접근 통제의 예시
        | 예시 | 설명 |
        |---|------|
        | IP 주소에 따른 접근 통제 | 특정 애플리케이션에 접근할 수 잇는 사용자의 IP 주소 외에 다른 주소는 접근을 차단하는 방법 |
        | MAC 주소에 따른 접근 통제 | (무선 AP) 무선 노트북의 MAC 주소에 기반을 두고 인증된 장치 외에는 아예 접근하지 못하도록 하는 방법 |
        | 인터페이스 통제 | 필요한 기능만 사용할 수 있도록 메뉴나 셸의 형태로 인터페이스를 제공하는 것 <br/> &nbsp;&nbsp; - 이용자는 주어진 메뉴 외에는 다른 조작이 불가능함 |

<br/>

* 물리적 접근 통제
    - 네트워크 분리(망 분리), 경계선 보안, 전산실 통제, 데이터 백업 등이 대표적임
        | 종류 | 설명 |
        |---|------|
        | 네트워크 분리(망 분리) | 특정 네트워크를 물리적으로 다른 네트워크와 분리하는 것 <br> &nbsp;&nbsp; - 민감하고 중요한 네트워크를 사용하는 기업이나 외부 해킹의 위험이 큰 기업에서는 물리적으로 네트워크를 분리해서 사용하는 경우가 있음 |
        | 경계선 보안 | 직원이 제한 구역이나 통제 구역에 들어갈 때 신원을 확인하는 것 <br/> &nbsp;&nbsp; - 전산실 통제도 비슷한 맥락으로 사용함 |
        | 스위치와 리우터의 설치 장소 | 대부분의 장소에서 네트워크 IP나 PC에 대한 통제는 하지만, 스위치나 라우터 장비는 그대로 노출시키는 경우가 많음 <br/> → ⚠️ 임의의 라인을 꽂아 해킹에 이용할 수 있으므로 **네트워크 장비에 임의로 접근할 수 없도록 잠금장치 등을 설치해놓어야 함** |

<br/><br/>

## 입력값 검증
📌 웹 애플리케이션 취약점의 대부분은 **사용자 입력값을 적절하게 검증하지 못해서 발생함**
* SQL Injection, XSS, File Vulnerability 등 대부분의 중대한 웹 애플리케이션 취약점은 사용자가 입력한 값을 검사하여 이상 여부만 판단해도 예방할 수 있음

<br/>

### 다양힙 입력값 검증 방법
| 유형 | 설명 |
|---|------|
| SQL Injection<br/> 공격 코드 <br/> 입력값 검증 | 📖 SQL Injection 취약점: 웹 애플리케이션에서 **사용자가 입력한 값을 받아 데이터베이스와 상호작용을 할 때** <br/>입력한 값을 제대로 검증하지 못해서 발생하는 취약점 <br/> &nbsp;&nbsp;&nbsp;&nbsp; → **데이터베이스와 연동하는 코드 부분**에 검증 루틴이 없을 경우 공격자는 조작한 SQL 쿼리문을 전달할 수 있음 <br/> - SQL Injection 취약점을 제거하려면 preparedStatement 객체를 이용하여 데이터베이스에 컴파일된 쿼리문을 전달하는 <br/> &nbsp;&nbsp;&nbsp;방식을 사용 <br/> &nbsp;&nbsp;&nbsp;&nbsp; - 외부에서 변수를 받는 부분에 prepareStatement 객체를 상수 문자열로 생성하고, <br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 매개변수 부분을 ```setXXX``` 메서드로 설정하여 외부 입력값이 쿼리문의 구조를 바꾸는 것을 방지함 (가장 안전함)
| XSS 공격 코드 <br/> 입력값 검증 | - XSS 공격을 예방하려면 **외부에서 스크립트 코드를 입력하지 못하도록 방어하는 것**이 가장 효과적임 <br/> &nbsp;&nbsp;&nbsp;&nbsp; - 스크립트를 입력하기 위한 문자열 ```<```, ```>```, ```&```, ```"``` 등을 ```&lt```, ```&gt```, ```&amp```, ```&quot```로 치환함 |
| File Upload <br/>Vulnerability <br/> 공격 입력값 검증 | - 악성 파일 업로드 공격을 방어하기 위해서는 **필요한 파일의 확장자만 업로드를 허용**해야 함 (Allowlist 필터링 방식 적용) <br/> &nbsp;&nbsp;&nbsp;&nbsp; - 그 외에도 업로드 되어 저장되는 파일의 크기, 개수, 실행 권한을 제한해야 함 <br/> - 업로드되는 파일을 저장할 때는 파일명과 확장자를 추측할 수 없도록 문자열 값을 변형하여 저장하는 것이 안전함 <br/> &nbsp;&nbsp;&nbsp;&nbsp; - 업로드 되어 저장되는 파일은 외부에서 식별되어야 함 |
* 그 외의 입력값 검증 방법은 [한국인터넷진흥원의 📖소프트웨어 개발 보안 가이드](https://www.kisa.or.kr/2060204/form?postSeq=5&lang_type=KO)를 참고

<br/>

### 입력값 검증 코드 구현
* 서버 측과 클라이언트 측 필터링
    - 입력값 검증을 위한 코드를 서버 측 프로그래밍 언어에 포함할지, 클라이언트 측 프로그래밍 언어에 포함할지에 따라 보안 수준이 확연히 달라짐
        + 클라이언트 측 필터링의 경우 공격자가 Burp Suite와 같은 웹 인터셉트 프로그램으로 무력화할 수 있음 <br/> → 📌 **웹 애플리케이션에서 사용자 입력값 검증 코드를 반드시 JSP, 자바, ASP와 같은 자바 측 프로그래밍 언어 내에서 구현해야 함**

<br/>

* Allowlist 방식과 Blocklist 방식의 필터링
    - 입력값 검증을 할 때에는 필터링해야 하는 악성 패턴이 존재함 → 어떻게 입력값을 필터링할 것인지 정해야 함
    - 필터링 방식의 종류
        | 필터링 방식 | 설명 |
        |---|------|
        | Allowlist 방식 | 필요한 특정 입력값만 받아들이고 그 외의 모든 값은 필터링함 <br/> &nbsp;&nbsp; = 특정 입력값만 허용하고 나머지는 모두 차단할 때 사용함|
        | Blocklist 방식 | 알려진 악성 패턴에 한해서만 필터링하고 그 외의 모든 값은 받아들임 <br/> &nbsp;&nbsp; = 대부분의 입력값은 허용하고 일부 특정 입력값만 차단할 때 사용함|
        + 과거에는 Whitelist, Blacklist라는 용어를 사용했으나 현재는 Allowlist, Blocklist로 대체되는 추세임
    - 📌 웹 애플리케이션에서는 블랙리스트 필터링 방식보다 **화이트리스트 필터링 방식을 선호함**


<br/><br/><br/><br/>
### 🔖 출처
* 인터넷 해킹과 보안[4판], 김경곤, 한빛아카데미 _ Page 236~263 (Chapter 09-01 ~ 03)
